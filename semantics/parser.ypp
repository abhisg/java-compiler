
%{
extern int yylineno;
extern char lexeme[64];
int error_count = 0;
int num_var=3;
int te=0;
int num_label=0;
int num_print=0;
int next_saved_reg=0,next_saved_float=20,next_loc_reg=3;
int break_allowed=0;
bool jump_found=false;
int method_count=0;
char newswitch[64],oldswitch[64],thisclass[64];
int offset_temp[100];

#define DEBUG_MODE 0
#define BYTE_CODE 0
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<vector>
#include<algorithm>
#include<stack>
using namespace std;

enum Basic
{
	tbyte,tshort,tint,tlong,tfloat,tdouble,tfinal,tboolean,tnull,tvoid,tchar,tstring,tnone
};

enum Modifier
{
	mpublic,mprivate,mstatic,mprotected,mabstract,mfinal,mnative,msynchronized,mtransient,mvolatile,mstrictfp
};

typedef struct STE
{
	char *lexeme;
	enum Basic btype;
	char ref[64];
	int dimension;
	int offset;			//offset in the stack
	vector<int> modifiers;
	struct ST *table;
}STE;

typedef struct ST
{
	struct ST *prev;
	vector<STE> entries;
}ST;

stack<int> break_label,continue_label,ident_label;
ST *currenter=NULL;
ST *node=NULL;
void createtable(ST *parent);
void removetable(ST *tab);
STE *findentry(ST *tab,char *lexeme);
void insertentry(ST *tab,char *lexeme,vector<int> m,enum Basic b,char *ref,int dimension,int offset);
bool compare(vector<struct attribute *>,vector<struct attribute *>);
char *getNewTemp(); 
char *offToAddr(int offset);
char *Address(char *var,int val=0);

enum refType
{
	memory,reg,constant
};

enum refType Ref(char *str)
{
	if(str[0]=='$')
		return reg;
	else if(str[0]!='\"' && (str[0]=='(' || str[1]=='(' || str[2]=='(' || str[3]=='(' || str[4]=='('))
		return memory;
	return constant;
}

enum Basic findType(char tmp[],int size);

struct attribute
{
	int token;
	union
	{
		enum Basic type;
		char ref[64];
	};
	int dimension;
	char value[64];
	char contains[64];
	vector<int> modifier;
};

struct ClassInterface
{
        char name[64];
        vector<int> modifiers;
	vector<struct methodConstructor *> listOfMethods;
        ST *table;
        struct ClassInterface *implements;
        struct ClassInterface *extends;
};

struct methodConstructor
{
	vector<struct attribute *>param;
	char name[64];
	int number;
	int token;
	union
	{
		enum Basic type;
		char ref[64];
	};
	vector<int> modifier;
};

ST *temp;
int currenterpointer=-1;
bool publicFound=false;
bool returnFound=false;
int forSt=0;
char *publicName;
char id[64];
vector<ClassInterface>listOfClasses;
vector<int>listOfModifiers;
vector<struct attribute *> variables;		
vector<struct attribute *> param;
stack<char *> switches;

stack<int> labels;
FILE *fcg;				/*code generator*/
struct attribute *typeinfo;
struct attribute *returninfo;
struct attribute *currentobject=NULL;
struct methodConstructor *m;

int num_temp=0;					/*for code generation*/

extern "C"
{
	void yyerror(const char *str)
	{
        	error_count++;
        	fprintf(stderr,"error: %s on line %d\n",str,yylineno);
	}
	int yywrap()
	{		
		return 1;
	}
	int yylex(void);
}
%}

%union
{
	struct attribute *attr;
	char str[1024];
}

%expect 1
%error-verbose
%token ERROR
%token PRINTL
%token PRINT

%token STRING
%token CHARACTERS
%token BOOL
%token NULLER
%token IDENTIFIER
%token HEX_INT
%token BIN_INT
%token OCT_INT
%token INTEGER
%token HEX_INT_LONG
%token BIN_INT_LONG
%token OCT_INT_LONG
%token INTEGER_LONG
%token FLOATING
%token HEX_FLOAT
%token FLOATING_FL
%token HEX_FLOAT_FL

%token ABSTRACT
%token ASSERT
%token BOOLEAN
%token BREAK
%token BYTE
%token CASE
%token CATCH
%token CHAR
%token CLASS
%token CONST
%token CONTINUE
%token DEFAULT
%token DO
%token DOUBLE
%token ELSE
%token ENUM
%token EXTENDS
%token FINAL
%token FINALLY
%token FLOAT
%token FOR
%token IF
%token GOTO
%token IMPLEMENTS
%token IMPORT
%token INSTANCEOF
%token INT
%token INTERFACE
%token LONG
%token NATIVE
%token NEW
%token PACKAGE
%token PRIVATE
%token PROTECTED
%token PUBLIC
%token RETURN
%token SHORT
%token STATIC
%token STRICTFP
%token SUPER
%token SWITCH
%token SYNCHRONIZED
%token THIS
%token THROW
%token THROWS
%token TRANSIENT
%token TRY
%token VOID
%token VOLATILE
%token WHILE

%token LRBRACE
%token RRBRACE
%token LCBRACE
%token RCBRACE
%token LSBRACE
%token RSBRACE
%token COMMA
%token SEMICOLON
%token DOT
%token COLON

%token TERNARY
%token INCREMENT
%token DECREMENT
%token UNOT
%token NEQ
%token NOT
%token COMPARE
%token EQUAL
%token MULTEQUAL
%token PLUSEQUAL
%token DIVEQUAL
%token MINUSEQUAL
%token MODEQUAL
%token DIV
%token MULT
%token MOD
%token PLUS
%token MINUS
%token LEFTSHIFTEQUAL
%token RIGHTSHIFTEQUAL
%token URIGHTSHIFTEQUAL
%token LEFTSHIFT
%token RIGHTSHIFT
%token URIGHTSHIFT
%token LEQ
%token LT
%token GT
%token GEQ
%token ANDEQUAL
%token BAND
%token OREQUAL
%token BOR
%token AND
%token OR
%token XOR
%token XOREQUAL

%right EQUAL PLUSEQUAL MINUSEQUAL MULTEQUAL DIVEQUAL MODEQUAL ANDEQUAL XOREQUAL OREQUAL LEFTSHIFTEQUAL RIGHTSHIFTEQUAL URIGHTSHIFTEQUAL 
%left  OR
%left  AND
%left  BOR
%left  XOR
%left  BAND
%left  COMPARE NEQ
%left  LT LEQ GT GEQ INSTANCEOF
%left  LEFTSHIFT RIGHTSHIFT URIGHTSHIFT
%left  PLUS MINUS
%left  MULT DIV MOD
%right PREINCREMENT PREDECREMENT UPLUS UMINUS NOT UNOT CAST
%right INCREMENT DECREMENT

%type <str>  Identifier
%type <str>  SimpleName
%type <attr> Literal
%type <attr> IntegerLiteral
%type <attr> FloatingPointLiteral

%type <attr> Cast
%type <attr> Type
%type <attr> Primitive
%type <attr> Numeric
%type <attr> Integral
%type <attr> FloatingPointType
%type <attr> Reference
%type <attr> Interfaces
%type <attr> InterfaceTypeList
%type <attr> ClassOrInterfaceType
%type <attr> TypeName
%type <attr> ArrayType
%type <attr> Modifiers
%type <attr> Modifier
%type <attr> FieldDeclaration
%type <attr> VariableInitialiser
%type <attr> VariableInitialisers
%type <attr> ArrayInitialiser
%type <attr> StatementExpression
%type <attr> Assignment
%type <attr> PreFixOp
%type <attr> PostFixOp
%type <attr> MethodInvocation
%type <attr> ClassInstanceCreationExpression
%type <attr> Primary
%type <attr> PrimaryNoNewArray
%type <attr> ArrayCreationExpression
%type <attr> DimExprs
%type <attr> Dims
%type <attr> FieldAccess
%type <attr> ArrayAccess
%type <attr> OpExpression
%type <attr> UnaryExpression
%type <attr> AddExpression
%type <attr> MultExpression
%type <attr> ShiftExpression
%type <attr> RelExpression
%type <attr> CompExpression
%type <attr> BitAndExpression
%type <attr> XORExpression
%type <attr> BORExpression
%type <attr> ANDExpression
%type <attr> ORExpression
%type <attr> TernaryExpression
%type <attr> Expression
%type <attr> LeftHandSide
%type <attr> SwitchBlockStatementGroups
%type <attr> SwitchBlockStatementGroup
%type <attr> SwitchLabels
%type <attr> SwitchLabel
%type <attr> VariableDeclaratorID
%type <attr> DimExpr

%type <str> AddOperator
%type <str> MultOperator
%type <str> ShiftOperator
%type <str> RelOperator
%type <str> CompOperator
%type <str> UnaryLtoR
%type <str> UnaryRtoL
%type <str> AssignmentOperator

%%

Goal:
	{
		fprintf(fcg,".data\n");
		fprintf(fcg,"newline:\t.asciiz \"\\n\"\n\n");
		fprintf(fcg,".text\n");
	}CompilationUnit{printf("Compilation complete\n");}
;

Identifier:
	IDENTIFIER		{ strcpy($$,yylval.str);}
;

Literal:
	IntegerLiteral		{ $$=$1; }
	|	
	FloatingPointLiteral    { $$=$1; }
	|
	BOOL			
	{  	$$=new struct attribute;
		$$->type=tboolean; 
		$$->token=1;
		$$->dimension=0;
		if(!strcmp(lexeme,"true"))
			strcpy($$->contains,"1");
		else
			strcpy($$->contains,"0");	
	}	
	|
	CHARACTERS		{  $$=new struct attribute;$$->type=tchar;strcpy($$->contains,lexeme);$$->token=1;$$->dimension=0;}	
	|
	STRING			{  $$=new struct attribute;strcpy($$->ref,"String");strcpy($$->contains,lexeme); $$->token=2;$$->dimension=0;}
	|
	NULLER			{  $$=new struct attribute;$$->type=tnull;strcpy($$->contains,lexeme); $$->token=1;$$->dimension=0;}
	|
	ERROR			{  $$=new struct attribute;$$->type=tnone;printf("ERROR:Erraneous literal at line %d\n",yylineno);}		
;

IntegerLiteral:
	INTEGER			
	{  
		$$=new struct attribute;
		$$->token=1;
		$$->dimension=0;
		char val[64];
		int j=0;
		for(int i=0;i<strlen(lexeme);i++)
		{
			if(lexeme[i]>='0' && lexeme[i]<='9')
				val[j++]=lexeme[i];
		}
		val[j]='\0';
		strcpy($$->contains,val);
		$$->type=findType(val,strlen(val)); 
	}
	|
	HEX_INT			{  $$=new struct attribute;$$->type=tint; $$->token=1;$$->dimension=0;}
	|
	BIN_INT			{  $$=new struct attribute;$$->type=tint; $$->token=1;$$->dimension=0;}
	|
	OCT_INT			{  $$=new struct attribute;$$->type=tint; $$->token=1;$$->dimension=0;}
	|
	INTEGER_LONG		
	{  
		$$=new struct attribute;
		$$->type=tlong; 
		$$->token=1;
		$$->dimension=0;
		char val[64];
		int j=0;
		for(int i=0;i<strlen(lexeme);i++)
		{
			if(lexeme[i]>='0' && lexeme[i]<='9')
				val[j++]=lexeme[i];
		}
		val[j]='\0';
		strcpy($$->contains,val);
	}
	|
	HEX_INT_LONG		{  $$=new struct attribute;$$->type=tlong; $$->token=1;$$->dimension=0;}
	|
	BIN_INT_LONG		{  $$=new struct attribute;$$->type=tlong; $$->token=1;$$->dimension=0;}
	|
	OCT_INT_LONG		{  $$=new struct attribute;$$->type=tlong; $$->token=1;$$->dimension=0;}
	
;

FloatingPointLiteral:
	HEX_FLOAT		{  $$=new struct attribute;$$->type=tdouble; $$->token=1;$$->dimension=0;}
	|
	FLOATING		
	{  
		$$=new struct attribute;
		$$->type=tdouble; 
		$$->token=1;
		$$->dimension=0;
		char val[64];
		int j=0;
		for(int i=0;i<strlen(lexeme);i++)
		{
			if((lexeme[i]>='0' && lexeme[i]<='9') || (lexeme[i]=='.'))
				val[j++]=lexeme[i];
		}
		val[j]='\0';
		strcpy($$->contains,val);
	}
	|
	HEX_FLOAT_FL		{  $$=new struct attribute;$$->type=tfloat; $$->token=1;$$->dimension=0;}
	|
	FLOATING_FL		
	{  
		$$=new struct attribute;
		$$->type=tfloat; 
		$$->token=1;
		$$->dimension=0;
		char val[64];
		int j=0;
		for(int i=0;i<strlen(lexeme);i++)
		{
			if((lexeme[i]>='0' && lexeme[i]<='9') || (lexeme[i]=='.'))
				val[j++]=lexeme[i];
		}
		val[j]='\0';
		strcpy($$->contains,val);
	}
;

Type:
	Primitive		
	{ 	$$=$1;
		typeinfo=new struct attribute;
		typeinfo->type=$$->type;
		typeinfo->token=$$->token;
		typeinfo->dimension=$$->dimension;
	}
	|
	Reference		
	{ 	$$=$1;
		typeinfo=new struct attribute;
		typeinfo->token=$$->token;
		//printf("%d\n",typeinfo->token);
		strcpy(typeinfo->ref,$$->ref);
		typeinfo->dimension=$$->dimension;
	}
;
Primitive:
	Numeric			{ $$=$1; }
	|
	BOOLEAN			{  $$=(struct attribute *)malloc(sizeof(struct attribute));$$->type=tboolean; $$->token=1; $$->dimension=0;}
;
Numeric:
	Integral		{ $$=$1; } 
	|
	FloatingPointType       { $$=$1; }
;
Integral:
	BYTE			{  $$=(struct attribute *)malloc(sizeof(struct attribute));$$->type=tbyte; $$->token=1; $$->dimension=0;}
	|
	SHORT			{ $$=(struct attribute *)malloc(sizeof(struct attribute));$$->type=tshort; $$->token=1; $$->dimension=0;}
	|
	INT			{ $$=(struct attribute *)malloc(sizeof(struct attribute));$$->type=tint; $$->token=1; $$->dimension=0;}
	|
	LONG			{ $$=(struct attribute *)malloc(sizeof(struct attribute)); $$->type=tlong; $$->token=1; $$->dimension=0;}
	|
	CHAR			{  $$=(struct attribute *)malloc(sizeof(struct attribute));$$->type=tchar; $$->token=1; $$->dimension=0;}
;
FloatingPointType:
	FLOAT			{  $$=(struct attribute *)malloc(sizeof(struct attribute));$$->type=tfloat; $$->token=1; $$->dimension=0;}
	|
	DOUBLE			{  $$=(struct attribute *)malloc(sizeof(struct attribute));$$->type=tdouble; $$->token=1; $$->dimension=0;}
;
Reference:
	ClassOrInterfaceType	{ $$=$1; }
	|
	ArrayType		{ $$=$1; }
;

ClassOrInterfaceType:
	TypeName		{ $$=$1; }
;
TypeName:
	SimpleName		{ $$=(struct attribute *)malloc(sizeof(struct attribute));strcpy($$->ref,$1);strcpy($$->contains,$1); $$->token=2; $$->dimension=0;}
;
SimpleName:		
	Identifier		{  strcpy($$,$1);}
;
ArrayType:
	Primitive LSBRACE RSBRACE	{  $$=(struct attribute *)malloc(sizeof(struct attribute));$$->type=$1->type;$$->token=3;$$->dimension=1;}
	|
	TypeName LSBRACE RSBRACE	{  $$=(struct attribute *)malloc(sizeof(struct attribute));strcpy($$->ref,$1->ref); $$->token=4;$$->dimension=1;}
	|
	ArrayType LSBRACE RSBRACE
	{ 	
		$$=(struct attribute *)malloc(sizeof(struct attribute));
		if($1->token==3)
		{
			$$->type=$1->type;	
			$$->token=3;
		}
		else if($1->token==4)
		{
			strcpy($$->ref,$1->ref);
			$$->token=4;
		}
		$$->dimension=$1->dimension+1;
	}
	|
	Primitive LSBRACE error SEMICOLON { $$=(struct attribute *)malloc(sizeof(struct attribute));$$->type=tnone;printf("ERROR:missing ] on %d\n",yylineno);}
	|
	TypeName LSBRACE error SEMICOLON { $$=(struct attribute *)malloc(sizeof(struct attribute));$$->type=tnone;printf("ERROR:missing ] on %d\n",yylineno);}
        |
        ArrayType LSBRACE error SEMICOLON { $$=(struct attribute *)malloc(sizeof(struct attribute));$$->type=tnone;printf("ERROR:missing ] on %d\n",yylineno);}
;

CompilationUnit:
	PackageDeclaration ImportDeclarations TypeDeclarations 
	|
	PackageDeclaration TypeDeclarations			
	|
	ImportDeclarations TypeDeclaration
	|
	TypeDeclarations					
	|
;

PackageDeclaration:
	PACKAGE TypeName SEMICOLON
	|
	PACKAGE error SEMICOLON					
;

ImportDeclarations:
	ImportDeclaration					
	|
	ImportDeclarations ImportDeclaration			
;

ImportDeclaration:
	IMPORT TypeName SEMICOLON
	|
	IMPORT TypeName DOT MULT SEMICOLON	       
	|
	IMPORT STATIC TypeName DOT Identifier SEMICOLON
	|
	IMPORT STATIC TypeName DOT MULT SEMICOLON
	|
	IMPORT error SEMICOLON
	|
	IMPORT STATIC error SEMICOLON					
;

TypeDeclarations:
	TypeDeclaration						
	|
	TypeDeclarations TypeDeclaration			
;	

TypeDeclaration:
	ClassDeclaration					
	|
	InterfaceDeclaration
;

ClassDeclaration:
	NormalClassDeclaration		
	|
	EnumDeclaration			

NormalClassDeclaration:
	Modifiers CLASS Identifier EXTENDS ClassOrInterfaceType Interfaces
        {
		for(int i=0;i<listOfModifiers.size();i++) {
		if(!(listOfModifiers[i]==mpublic||listOfModifiers[i]==mprivate||\
		listOfModifiers[i]==mprotected||listOfModifiers[i]==mabstract||listOfModifiers[i]==mstatic||listOfModifiers[i]==mfinal||listOfModifiers[i]==mstrictfp )) 
				printf("ERROR:Incorrect modifier at line %d\n",yylineno);}
		currenterpointer++;
                	createtable(currenter);
                	ClassInterface cl;
                	strcpy(cl.name,$3);
                	cl.table=new ST;
			cl.extends=(ClassInterface *)malloc(sizeof(ClassInterface));
			cl.implements=(ClassInterface *)malloc(sizeof(ClassInterface));
                	cl.table=currenter;
			int i;
                	for(i=0;i<listOfClasses.size();i++)
                	{
                                if(strcmp(listOfClasses[i].name,$5->ref)==0)
                                        break;
                        }
                        if(i==listOfClasses.size())
			{
				cl.extends=NULL;
                                printf("ERROR:error in class declaration.No class/interface of name %s found\n",$5->ref);
			}
                        else
                                *(cl.extends)=listOfClasses[i];  
			//printf("here\n");
                        for(i=0;i<listOfClasses.size();i++)
                        {
                                if(strcmp(listOfClasses[i].name,$6->ref)==0)
                                        break;
                        }
                        if(i==listOfClasses.size())
			{
				cl.implements=NULL;
                                printf("ERROR:Error in class declaration.No class/interface of name %s found\n",$6->ref);
			}
                        else
                                *(cl.implements)=listOfClasses[i]; 
                        cl.modifiers=listOfModifiers;
                        listOfModifiers.clear();
                	for(i=0;i<listOfClasses.size();i++)
                	{
                                if(strcmp(listOfClasses[i].name,cl.name)==0)
                                        break;
                        }
			if(i==listOfClasses.size())
                        	listOfClasses.push_back(cl);
			else
			{currenterpointer--;printf("ERROR:Multiple definition of class %s on line %d\n",cl.name,yylineno);}
        }ClassBody
	{currenter=NULL;}
	|
	CLASS Identifier EXTENDS ClassOrInterfaceType Interfaces 
	{
			currenterpointer++;
                        createtable(currenter);
                        ClassInterface cl;
                        strcpy(cl.name,$2);
                        cl.table=(ST *)malloc(sizeof(ST));
                        cl.table=currenter;
			cl.extends=(ClassInterface *)malloc(sizeof(ClassInterface));
			cl.implements=(ClassInterface *)malloc(sizeof(ClassInterface));	
			int i;
                        for(i=0;i<listOfClasses.size();i++)
                        {
                                if(strcmp(listOfClasses[i].name,$4->ref)==0)
                                        break;
                        }
                        if(i==listOfClasses.size())
			{
				cl.extends=NULL;
                                printf("ERROR:Error in class declaration.No class/interface of name %s found\n",$4->ref);
			}
                        else
                                *(cl.extends)=listOfClasses[i];
                        for(i=0;i<listOfClasses.size();i++)
                        {
                                if(strcmp(listOfClasses[i].name,$5->ref)==0)
                                        break;
                        }
                        if(i==listOfClasses.size())
			{
				cl.implements=NULL;
                                printf("ERROR:Error in class declaration.No class/interface of name %s found\n",$5->ref);
			}
                        else
                                *(cl.implements)=listOfClasses[i];
                        cl.modifiers.push_back(mnative);
                	for(i=0;i<listOfClasses.size();i++)
                	{
                                if(strcmp(listOfClasses[i].name,cl.name)==0)
                                        break;
                        }
			if(i==listOfClasses.size())
                        	listOfClasses.push_back(cl);
			else
			{currenterpointer--;printf("ERROR:Multiple definition of class %s on line %d\n",cl.name,yylineno);}
                        
        }ClassBody{currenter=NULL;}
	|
	Modifiers CLASS Identifier Interfaces
	{ 
		for(int i=0;i<listOfModifiers.size();i++) {if(!(listOfModifiers[i]==mpublic || listOfModifiers[i]==mprivate ||listOfModifiers[i]==mprotected || listOfModifiers[i]==mabstract || listOfModifiers[i]==mstatic ||listOfModifiers[i]==mfinal || listOfModifiers[i]==mstrictfp) ) 
                                printf("ERROR:Incorrect modifier at line %d\n",yylineno);}
		currenterpointer++;
                createtable(currenter);
                ClassInterface cl;
                strcpy(cl.name,$3);
                cl.table=(ST *)malloc(sizeof(ST));
		cl.table=currenter;
		cl.extends=(ClassInterface *)malloc(sizeof(ClassInterface));
		cl.implements=(ClassInterface *)malloc(sizeof(ClassInterface));	
		cl.extends=NULL;
                cl.table=currenter;
		int i;
		for(i=0;i<listOfClasses.size();i++)
                {
                        if(strcmp(listOfClasses[i].name,$4->ref)==0)
                                break;
                }
                if(i==listOfClasses.size())
		{
		       cl.implements=NULL;	
                       printf("ERROR:Error in class declaration.No class/interface of name %s found\n",$4->ref);
		}
                else
                       *(cl.implements)=listOfClasses[i];
                cl.modifiers=listOfModifiers;
                listOfModifiers.clear();
                	for(i=0;i<listOfClasses.size();i++)
                	{
                                if(strcmp(listOfClasses[i].name,cl.name)==0)
                                        break;
                        }
			if(i==listOfClasses.size())
                        	listOfClasses.push_back(cl);
			else
			{currenterpointer--;printf("ERROR:Multiple definition of class %s on line %d\n",cl.name,yylineno);}
                
        }
	ClassBody{currenter=NULL;}
	|
	Modifiers CLASS Identifier EXTENDS ClassOrInterfaceType 
	{
		int i;
		for(i=0;i<listOfModifiers.size();i++) {if(!(listOfModifiers[i]==mpublic || listOfModifiers[i]==mprivate ||listOfModifiers[i]==mprotected || listOfModifiers[i]==mabstract || listOfModifiers[i]==mstatic ||listOfModifiers[i]==mfinal || listOfModifiers[i]==mstrictfp) ) 
                                printf("ERROR:Incorrect modifier at line %d\n",yylineno);}
		currenterpointer++;
                createtable(currenter);
                ClassInterface cl;
                strcpy(cl.name,$3);
                cl.table=(ST *)malloc(sizeof(ST));
                cl.table=currenter;
                cl.implements=(ClassInterface *)malloc(sizeof(ClassInterface));
		cl.implements=NULL;
		cl.extends=(ClassInterface *)malloc(sizeof(ClassInterface));	
                for(i=0;i<listOfClasses.size();i++)
                {
                         if(strcmp(listOfClasses[i].name,$5->ref)==0)
                               break;
                }
                if(i==listOfClasses.size())
		{
			cl.extends=NULL;
                        printf("ERROR:Error in class declaration.No class/interface of name %s found\n",$5->ref);
		}
                else
                    	*(cl.extends)=listOfClasses[i];
                cl.modifiers=listOfModifiers;
                listOfModifiers.clear();
                	for(i=0;i<listOfClasses.size();i++)
                	{
                                if(strcmp(listOfClasses[i].name,cl.name)==0)
                                        break;
                        }
			if(i==listOfClasses.size())
                        	listOfClasses.push_back(cl);
			else
			{currenterpointer--;printf("ERROR:Multiple definition of class %s on line %d\n",cl.name,yylineno);}
               
       } ClassBody{currenter=NULL;}
	|
	CLASS Identifier Interfaces 
	{
		currenterpointer++;
                createtable(currenter);
                ClassInterface cl;
                strcpy(cl.name,$2);
                cl.table=(ST *)malloc(sizeof(ST));
                cl.implements=(ClassInterface *)malloc(sizeof(ClassInterface));
		cl.extends=(ClassInterface *)malloc(sizeof(ClassInterface));	
          	cl.extends=NULL;
                cl.table=currenter;
		int i;
                for(i=0;i<listOfClasses.size();i++)
                {
                                if(strcmp(listOfClasses[i].name,$3->ref)==0)
                                        break;
                }
                if(i==listOfClasses.size())
		{
			cl.implements=NULL;
                        printf("ERROR:Error in class declaration.No class/interface of name %s found\n",$3->ref);
		}
                else
                        *(cl.implements)=listOfClasses[i];
                cl.modifiers.push_back(mnative);
		        for(i=0;i<listOfClasses.size();i++)
                	{
                                if(strcmp(listOfClasses[i].name,cl.name)==0)
                                        break;
                        }
			if(i==listOfClasses.size())
                        	listOfClasses.push_back(cl);
			else
			{currenterpointer--;printf("ERROR:Multiple definition of class %s on line %d\n",cl.name,yylineno);}
        } ClassBody{currenter=NULL;}
	|
	CLASS Identifier EXTENDS ClassOrInterfaceType 
	{
			currenterpointer++;
                        createtable(currenter);
                        ClassInterface cl;
                        strcpy(cl.name,$2);
                        cl.table=(ST *)malloc(sizeof(ST));
                        cl.extends=(ClassInterface *)malloc(sizeof(ClassInterface));
                        cl.implements=(ClassInterface *)malloc(sizeof(ClassInterface));
			cl.implements=NULL;				
                        cl.table=currenter;
			int i;
                        for(i=0;i<listOfClasses.size();i++)
                        {
                                if(strcmp(listOfClasses[i].name,$4->ref)==0)
                                        break;
                        }
                        if(i==listOfClasses.size())
			{
				cl.extends=NULL;
                                printf("ERROR:Error in class declaration.No class/interface of name %s found\n",$4->ref);
			}
                        else
                                *(cl.extends)=listOfClasses[i];
                        cl.modifiers.push_back(mnative);
                        
                	for(i=0;i<listOfClasses.size();i++)
                	{
                                if(strcmp(listOfClasses[i].name,cl.name)==0)
                                        break;
                        }
			if(i==listOfClasses.size())
                        	listOfClasses.push_back(cl);
			else
			{currenterpointer--;printf("ERROR:Multiple definition of class %s on line %d\n",cl.name,yylineno);}
        } ClassBody{currenter=NULL;}
	|
	Modifiers CLASS Identifier
	{
			int i;
			for(i=0;i<listOfModifiers.size();i++) {if(!(listOfModifiers[i]==mpublic || listOfModifiers[i]==mprivate ||listOfModifiers[i]==mprotected || listOfModifiers[i]==mabstract || listOfModifiers[i]==mstatic ||listOfModifiers[i]==mfinal || listOfModifiers[i]==mstrictfp )) 
                                printf("ERROR:Incorrect modifier at line %d\n",yylineno);}
			currenterpointer++;
                        createtable(currenter);
                        ClassInterface cl;
                        strcpy(cl.name,$3);
                        cl.table=(ST *)malloc(sizeof(ST));
                        cl.table=currenter;
                        cl.extends=(ClassInterface *)malloc(sizeof(ClassInterface));
                        cl.implements=(ClassInterface *)malloc(sizeof(ClassInterface));
			cl.implements=NULL;				
			cl.extends=NULL;
                        cl.modifiers=listOfModifiers;
                        listOfModifiers.clear();
                        
                	for(i=0;i<listOfClasses.size();i++)
                	{
                                if(strcmp(listOfClasses[i].name,cl.name)==0)
                                        break;
                        }
			if(i==listOfClasses.size())
                        	listOfClasses.push_back(cl);
			else
			{currenterpointer--;printf("ERROR:Multiple definition of class %s on line %d\n",cl.name,yylineno);}
        } ClassBody{currenter=NULL;}
	|
	CLASS Identifier 
	{
			currenterpointer++;
                        createtable(currenter);
                        ClassInterface cl;
                        strcpy(cl.name,$2);
                        cl.table=(ST *)malloc(sizeof(ST));
                        cl.table=currenter;
                        cl.modifiers=listOfModifiers;
                        cl.extends=(ClassInterface *)malloc(sizeof(ClassInterface));
                        cl.implements=(ClassInterface *)malloc(sizeof(ClassInterface));
			cl.implements=NULL;				
			cl.extends=NULL;
			cl.modifiers.push_back(mnative);
			int i;
                	for(i=0;i<listOfClasses.size();i++)
                	{
                                if(strcmp(listOfClasses[i].name,cl.name)==0)
                                        break;
                        }
			if(i==listOfClasses.size())
                        	listOfClasses.push_back(cl);
			else
			{currenterpointer--;printf("ERROR:Multiple definition of class %s on line %d\n",cl.name,yylineno);}
        } ClassBody{currenter=NULL;}
	|
	Modifiers CLASS error ClassBody
	|
	CLASS error ClassBody
;

Modifiers:
	Modifiers Modifier
	{	int i;
		//printf("%d\n",$2->modifier[0]);	
		for(i=0;i<listOfModifiers.size();i++) {
			if($2->modifier[0]==listOfModifiers[i]) break;
		} 
		if(i==listOfModifiers.size()) 
			listOfModifiers.push_back($2->modifier[0]) ;
		else 
			printf("ERROR:Erroneous modifier declaration at line %d\n",yylineno);
		publicFound=false;
	}
	|
	Modifier
	{	
		//printf("%d\n",$1->modifier[0]);
		int i;
		for(i=0;i<listOfModifiers.size();i++) {
			if($1->modifier[0]==listOfModifiers[i]) break;}
		if(i==listOfModifiers.size()) 
			listOfModifiers.push_back($1->modifier[0]);
		else 
			printf("ERROR:Erroneous modifier declaration at line %d\n",yylineno);
		publicFound=false;
	}
;
Modifier:			
	PUBLIC 
	{$$=new struct attribute;
	if(listOfModifiers.size()==0 && !publicFound) 
		publicFound=true; 
	else if(listOfModifiers.size()>0 && publicFound) 
		printf("ERROR:Error at line %d,public modifier already exists\n",yylineno);
		$$->modifier.push_back(mpublic);
	}
	|
	PRIVATE { $$=new struct attribute;$$->modifier.push_back(mprivate); }
	|
	PROTECTED {  $$=new struct attribute;$$->modifier.push_back(mprotected); }
	|
	ABSTRACT  {  $$=new struct attribute;$$->modifier.push_back(mabstract); }
	|
	STATIC    {  $$=new struct attribute;$$->modifier.push_back(mstatic); }
	|
	FINAL	  {  $$=new struct attribute;$$->modifier.push_back(mfinal); }
	|
	NATIVE	  {  $$=new struct attribute;$$->modifier.push_back(mnative); }	
	|
	SYNCHRONIZED {  $$=new struct attribute;$$->modifier.push_back(msynchronized); }
	|
	TRANSIENT   {  $$=new struct attribute;$$->modifier.push_back(mtransient); }
	|
	VOLATILE    {  $$=new struct attribute;$$->modifier.push_back(mvolatile); }
	|
	STRICTFP    {  $$=new struct attribute;$$->modifier.push_back(mstrictfp); }
;

Interfaces:
	IMPLEMENTS InterfaceTypeList	{ $$=$2; }
;

InterfaceTypeList:
	ClassOrInterfaceType	{ $$=$1; }
;

ClassBody:
	LCBRACE RCBRACE
	|
	LCBRACE ClassBodyDeclarations RCBRACE				
	|	
	LCBRACE error RCBRACE
;

ClassBodyDeclarations:
	ClassBodyDeclaration
	|
	ClassBodyDeclarations ClassBodyDeclaration
;

ClassBodyDeclaration:
	ClassMemberDeclaration			
	|
	Block
	|
	STATIC Block				
	|
	ConstructorDeclaration			
;

ClassMemberDeclaration:
	FieldDeclaration				
	|
	MethodDeclaration				
	|
	//ClassDeclaration	class nesting not allowed
	//|
	//InterfaceDeclaration				
	//|
	SEMICOLON
;

FieldDeclaration:
	Modifiers Type VariableDeclarators
	{
                for(int i=0;i<listOfModifiers.size();i++)
                {if(!(listOfModifiers[i]==mpublic || listOfModifiers[i]==mprivate || listOfModifiers[i]==mprotected \
		|| listOfModifiers[i]==mstatic || listOfModifiers[i]==mtransient ||listOfModifiers[i]==mfinal|| listOfModifiers[i]==mvolatile) ) printf("Incorrect modifier at line %d\n",yylineno);}   
		listOfModifiers.clear();
	}SEMICOLON
	|
	Type VariableDeclarators SEMICOLON
	//|
	//Modifiers error SEMICOLON			{printf("ERROR:missing identifiers at line %d\n",yylineno);}
	|
	Type error SEMICOLON				{printf("ERROR:missing identifiers at line %d\n",yylineno);}
;

VariableDeclarators:
	VariableDeclarator
	|
	VariableDeclarators COMMA VariableDeclarator 
;

VariableDeclarator:
	VariableDeclaratorID
	{
		if(listOfModifiers.size()==0)
			typeinfo->modifier.push_back(mnative);
		else
			typeinfo->modifier=listOfModifiers;
		if(findentry(currenter,id))	
			printf("ERROR:redefinition of variable %s at line %d\n",id,yylineno); 
		else
		{
			printf("installing %s in the symbol table %p\n",id,currenter);
			int offset;
			if(find(typeinfo->modifier.begin(),typeinfo->modifier.end(),mstatic)==typeinfo->modifier.end())
			{
				offset=-num_var*4;		//currently all types have fixed sizes
				num_var++;
			}
			else
			{
				if((typeinfo->type!=tfloat && typeinfo->type!=tdouble) || ($1->dimension+typeinfo->dimension!=0))
				{
					offset=50+next_saved_reg;
					next_saved_reg=(next_saved_reg+1)%7;
				}
				else
				{
					offset=60+next_saved_float;
					next_saved_float=(next_saved_float+1)%30>=20?(next_saved_float+1)%30:20;
				}
			}
			if(typeinfo->token==1 || typeinfo->token==3)
				insertentry(currenter,id,typeinfo->modifier,typeinfo->type,NULL,$1->dimension+typeinfo->dimension,offset);
			else if(typeinfo->token==2 || typeinfo->token==4)
				insertentry(currenter,id,typeinfo->modifier,tnone,typeinfo->ref,typeinfo->dimension+$1->dimension,offset);
		}
	}
	|
	VariableDeclaratorID EQUAL VariableInitialiser
	{
		if(listOfModifiers.size()==0)
			typeinfo->modifier.push_back(mnative);
		else
			typeinfo->modifier=listOfModifiers;
		if(typeinfo->token!=$3->token && $1->token!=$3->token)
			printf("ERROR:Type mismatch at line %d\n",yylineno);
		else if((typeinfo->dimension+$1->dimension) !=$3->dimension)
			printf("ERROR:Type mismatch at lien %d\n",yylineno);
		else if(typeinfo->token==1 || typeinfo->token==3)
		{
			//printf("%d %d\n",typeinfo->type,$3->type);
			if(typeinfo->type==tdouble && ($3->type==tstring || $3->type==tboolean || $3->type==tnull || $3->type==tvoid))
				printf("ERROR:Type mismatch at line %d\n",yylineno);
			else if(typeinfo->type==tfloat && ($3->type==tdouble || $3->type==tstring || $3->type==tboolean || $3->type==tnull || $3->type==tvoid)) 
				printf("ERROR:Type mismatch at line %d\n",yylineno);
			else if(typeinfo->type==tlong && ($3->type==tfloat || $3->type==tdouble || $3->type==tstring || $3->type==tboolean || $3->type==tnull || $3->type==tvoid))
				printf("ERROR:Type mismatch at lien %d\n",yylineno);
			else if(typeinfo->type==tint && ($3->type!=tint && $3->type!=tbyte && $3->type!=tshort && $3->type!=tchar))
				printf("ERROR:Type mismatch at line %d\n",yylineno);
			else if(typeinfo->type==tshort && ($3->type!=tbyte && $3->type!=tshort))
                                printf("ERROR:Type mismatch at line %d\n",yylineno);
			else if(typeinfo->type==tbyte && $3->type!=tbyte)
                                printf("ERROR:Type mismatch at line %d\n",yylineno);
			else if(typeinfo->type==tchar && $3->type!=tchar)
                                printf("ERROR:Type mismatch at line %d\n",yylineno);
			else if(typeinfo->type==tboolean && $3->type!=tboolean)	
				printf("ERROR:Type mismatch at line %d\n",yylineno);
			else
			{
				if(findentry(currenter,id))	
					printf("ERROR:redefinition of variable %s at line %d\n",id,yylineno); 
				else
				{
					int offset;
					if(find(typeinfo->modifier.begin(),typeinfo->modifier.end(),mstatic)==typeinfo->modifier.end())
					{
						offset=-num_var*4;		//currently all types have fixed sizes
						num_var++;
					}
					else
					{
						if(typeinfo->type!=tfloat && typeinfo->type!=tdouble)
						{
							offset=50+next_saved_reg;
							next_saved_reg=(next_saved_reg+1)%7;
						}
						else
						{
							offset=60+next_saved_float;
							next_saved_float=(next_saved_float+1)%30>=20?(next_saved_float+1)%30:20;
						}			
					}
					printf("installing %s in the symbol table %p\n",id,currenter);
					insertentry(currenter,id,typeinfo->modifier,typeinfo->type,NULL,typeinfo->dimension+$1->dimension,offset);
					char *val1=Address($1->contains);
					if(typeinfo->dimension+$1->dimension>0 && !jump_found)
					{
						fprintf(fcg,"li $a0,%d\n",(variables.size()+1)*4);
						fprintf(fcg,"li $v0,9\n");
						fprintf(fcg,"syscall\n");
						if(Ref(val1)==memory)
							fprintf(fcg,"sw $v0,%s\n",val1);
						else
							fprintf(fcg,"move $v0,%s\n",val1);
					}
					else if(typeinfo->dimension+$1->dimension>0 && jump_found)
					{
						fprintf(fcg,"lw $t0,%s\n",Address($3->contains));
						if(Ref(val1)==memory)
							fprintf(fcg,"sw $t0,%s\n",val1);
						else
							fprintf(fcg,"move $t0,%s\n",val1);
					}	
					int i;
					//printf("%s %d %d\n",$1->contains,variables.size(),jump_found);
					for(i=0;i<variables.size() && !jump_found;i++)
					{
						if(typeinfo->dimension+$1->dimension>0)
						{
							val1=Address($1->contains);
							if(Ref(val1)==memory)
								fprintf(fcg,"\nlw $t0,%s\n",val1);
							else
								fprintf(fcg,"\nmove $t0,%s\n",val1);
							fprintf(fcg,"li $t1,%d\n",(i+1)*4);
							fprintf(fcg,"addu $t3,$t0,$t1\n");
							strcpy(val1,"0($t3)");
						}
						char *val2=Address(variables[i]->contains);
						enum refType t1=Ref(val1);
						enum refType t2=Ref(val2);
						if(t1==memory)
						{
							if(t2==constant)
							{
								if(variables[i]->type!=tdouble && variables[i]->type!=tfloat)
								{
									fprintf(fcg,"li $t0,%s\n",val2);
									if($1->type!=tdouble && $1->type!=tfloat && $1->type!=tchar)
										fprintf(fcg,"sw $t0,%s\n",val1);
									else if($1->type==tchar)
										fprintf(fcg,"sb $t0,%s\n",val1);
									else
									{	
										fprintf(fcg,"mtc1 $t0,$f1\n");
										fprintf(fcg,"cvt.s.w $f1,$f1\n");
										fprintf(fcg,"s.s $f1,%s\n",val1);
									}
								}
								else
								{
									fprintf(fcg,"li.s $f0,%s\n",val2);
									fprintf(fcg,"s.s $f0,%s\n",val1);
								}
							}
							else if(t2==memory)
							{
								if(variables[i]->type!=tdouble && variables[i]->type!=tfloat)
								{
									fprintf(fcg,"lw $t0,%s\n",val2);
									if($1->type!=tdouble && $1->type!=tfloat && $1->type!=tchar)
										fprintf(fcg,"sw $t0,%s\n",val1);
									else if($1->type==tchar)
										fprintf(fcg,"sb $t0,%s\n",val1);
									else
									{	
										fprintf(fcg,"mtc1 $t0,$f1\n");
										fprintf(fcg,"cvt.s.w $f1,$f1\n");
										fprintf(fcg,"s.s $f1,%s\n",val1);
									}
								}
								else
								{
									fprintf(fcg,"l.s $f0,%s\n",val2);
									fprintf(fcg,"s.s $f0,%s\n",val1);
								}
							}
							else
							{
								if(variables[i]->type!=tdouble && variables[i]->type!=tfloat)
								{
									if($1->type!=tdouble && $1->type!=tfloat && $1->type!=tchar)
										fprintf(fcg,"sw %s,%s\n",val2,val1);
									else if($1->type==tchar)
										fprintf(fcg,"sb %s,%s\n",val2,val1);
									else
									{	
										fprintf(fcg,"move $t0,%s\n",val2);
										fprintf(fcg,"mtc1 $t0,$f1\n");
										fprintf(fcg,"cvt.s.w $f1,$f1\n");
										fprintf(fcg,"s.s $f1,%s\n",val1);
									}
								}
								else
									fprintf(fcg,"s.s %s,%s\n",val2,val1);
							}
						}
						else if(t1==reg)
						{
							if(t2==constant)
							{
								if(variables[i]->type!=tdouble && variables[i]->type!=tfloat)
								{
									if($1->type!=tdouble && $1->type!=tfloat)
										fprintf(fcg,"li %s,%s\n",val1,val2);
									else
									{	
										fprintf(fcg,"li $t0,%s\n",val2);
										fprintf(fcg,"mtc1 $t0,$f1\n");
										fprintf(fcg,"cvt.s.w $f1,$f1\n");
										fprintf(fcg,"mov.s %s\n,$f1",val1);
									}
								}
								else
									fprintf(fcg,"li.s %s,%s\n",val1,val2);
							}
							else if(t2==memory)
							{
								if(variables[i]->type!=tdouble && variables[i]->type!=tfloat)
								{
									fprintf(fcg,"lw $t0,%s\n",val2);
									if($1->type!=tdouble && $1->type!=tfloat)
										fprintf(fcg,"move %s,$t0\n",val1);
									else
									{	
										fprintf(fcg,"mtc1 $t0,$f1\n");
										fprintf(fcg,"cvt.s.w $f1,$f1\n");
										fprintf(fcg,"mov.s %s,$f1\n",val1);
									}
								}
								else
								{
									fprintf(fcg,"l.s $f0,%s\n",val2);
									fprintf(fcg,"mov.s %s,$f0\n",val1);
								}
							}
							else
							{
								if(variables[i]->type!=tdouble && variables[i]->type!=tfloat)
								{
									if($1->type!=tdouble && $1->type!=tfloat)
										fprintf(fcg,"move %s,%s\n",val1,val2);
									else
									{	
										fprintf(fcg,"move $t0,%s\n",val1);
										fprintf(fcg,"mtc1 $t0,$f1\n");
										fprintf(fcg,"cvt.s.w $f1,$f1\n");
										fprintf(fcg,"mov.s %s,$f1\n",val1);
									}
								}
								else
									fprintf(fcg,"mov.s %s,%s\n",val1,val2);
							}
						}
					}
					jump_found=false;
					variables.clear();
				}
                	}
		}
		else if(typeinfo->token==2 || typeinfo->token==4)
		{
			if(findentry(currenter,id))
				printf("ERROR:redefinition of variable %s at line %d\n",id,yylineno);
			else
			{
				bool found=false;
				if(!strcmp(typeinfo->ref,$3->ref))
				{
					int offset=-num_var*4;
					num_var++;
					insertentry(currenter,id,typeinfo->modifier,tnone,typeinfo->ref,typeinfo->dimension+$1->dimension,offset);
					char *val1=Address($1->contains);
					//if($1->dimension+typeinfo->dimension==0)
					//{
						if(Ref(Address($3->contains))==memory)
							fprintf(fcg,"lw $t0,%s\n",Address($3->contains));
						else
							fprintf(fcg,"move $t0,%s\n",Address($3->contains));
						if(Ref(val1)==memory)
							fprintf(fcg,"sw $t0,%s\n",val1);
						else
							fprintf(fcg,"move %s\n,$t0",val1);
					//}
				}
				else
					printf("ERROR:Type mismatch at line %d\n",yylineno);
			}
			jump_found=false;
		}		
		else
			printf("ERROR:Type mismatch at line %d\n",yylineno);
	}
	|
	VariableDeclaratorID EQUAL error SEMICOLON	{printf("ERROR:missing expression after = at line %d\n",yylineno);}
;

VariableDeclaratorID:
	VariableDeclaratorID LSBRACE RSBRACE
	{
		$$ = new struct attribute;
		if(typeinfo->token==1 || typeinfo->token==3)
		{
			$$->type=typeinfo->type;
			$$->token=3;
		}
		else
		{
			strcpy($$->ref,typeinfo->ref);
			$$->token=4;
		}
		$$->dimension=$1->dimension+1;
		strcpy($$->contains,$1->contains);
	}
	|
	VariableDeclaratorID LSBRACE error SEMICOLON	{$$=new struct attribute;$$->dimension=0;printf("ERROR:missing ] at line %d\n",yylineno);}
	|
	Identifier		
	{	
		$$ = new struct attribute;
		$$->dimension=0;
		$$->token=typeinfo->token;
		if(typeinfo->token==2 || typeinfo->token==4)
			strcpy($$->ref,typeinfo->ref);
		else
			$$->type=typeinfo->type;
		strcpy($$->contains,$1);
		strcpy(id,$1);
	}
;

VariableInitialiser:
	Expression
	{
		$$=(struct attribute *)malloc(sizeof(struct attribute));
		if($1->token==1 || $1->token==3)
		{
			$$->type=$1->type;
			$$->dimension=$1->dimension;
			$$->token=$1->token;
			strcpy($$->contains,$1->contains);
			variables.push_back($$);
		}
		else
		{
			strcpy($$->ref,$1->ref);
                        $$->dimension=$1->dimension;
                        $$->token=$1->token;
			strcpy($$->contains,$1->contains);
		}
	}
	|
	ArrayInitialiser
	{	
		$$=(struct attribute *)malloc(sizeof(struct attribute));
                if($1->token==3)
                {
                        $$->type=$1->type;
                        $$->dimension=$1->dimension;
                        $$->token=$1->token;
                }
                else if($1->token==4)
  		{
                        strcpy($$->ref,$1->ref);
                        $$->dimension=$1->dimension;
                        $$->token=$1->token;
                }
		else
			$$->type=tnone;
        }
;

ArrayInitialiser:
	LCBRACE RCBRACE		{$$=(struct attribute *)malloc(sizeof(struct attribute));$$->type=tchar;$$->dimension=1;$$->token=3;}
	|
	LCBRACE VariableInitialisers COMMA RCBRACE
	{	$$=(struct attribute *)malloc(sizeof(struct attribute));
		if($2->token==1 || $2->token==3)
		{
			$$->token=3;
			$$->type=$2->type;
		}
		else
		{
			$$->token=4;
			strcpy($$->ref,$2->ref);
		}
		$$->dimension=1+$2->dimension;
	}
	|
	LCBRACE COMMA RCBRACE	{$$=(struct attribute *)malloc(sizeof(struct attribute));$$->type=tchar;$$->dimension=1;$$->token=3;}
	|
	LCBRACE VariableInitialisers RCBRACE
	{	$$=(struct attribute *)malloc(sizeof(struct attribute));
		if($2->token==1 || $2->token==3)
		{
			$$->token=3;
			$$->type=$2->type;
		}
		else
		{
			$$->token=4;
			strcpy($$->ref,$2->ref);
		}
		$$->dimension=1+$2->dimension;
        }		
	|
	LCBRACE error RCBRACE				{	$$=(struct attribute *)malloc(sizeof(struct attribute));$$->type=tnone;}
	|
	LCBRACE VariableInitialisers error SEMICOLON	{	$$=(struct attribute *)malloc(sizeof(struct attribute));$$->type=tnone;printf("ERROR:Missing } on line %d\n",yylineno);}
;
VariableInitialisers:
	VariableInitialiser	{ $$=$1; }
	|
	VariableInitialisers COMMA VariableInitialiser
	{	$$=(struct attribute *)malloc(sizeof(struct attribute));
		if(!($1->token==2 || $3->token==2 || $1->token==4 || $3->token==4))
		{
			//printf("%d %d\n",$1->token,$3->token);
			$$->token=$1->token;
			$$->dimension=$1->dimension;
			if($1->dimension!=$3->dimension)
			{
				$$->type=tnone;
				printf("ERROR:array dimension mismatch at line %d\n",yylineno);
			}
			else if($1->type==tdouble && $3->type!=tstring && \
			$3->type!=tboolean && $3->type!=tnull && $3->type!=tvoid && $3->type!=tnone)
				$$->type=tdouble;
			else if($1->type==tfloat && $3->type!=tdouble \
			&& $3->type!=tstring && $3->type!=tboolean && $3->type!=tnull && $3->type!=tvoid && $3->type!=tnone)
				$$->type=tfloat;
			else if($1->type==tlong && ($3->type==tlong || $3->type==tint || $3->type==tbyte || $3->type==tshort || $3->type==tchar))
                        	$$->type=tlong;
                	else if($1->type==tint && ($3->type==tint || $3->type==tbyte || $3->type==tshort || $3->type==tchar))
                        	$$->type=tint;
                	else if($1->type==tshort && ($3->type==tbyte || $3->type==tshort))
                        	$$->type=tshort;
                	else if($1->type==tbyte && $3->type==tbyte)
                        	$$->type=tbyte;
                	else if($1->type==tchar && $3->type==tchar)
                        	$$->type=tchar;	
			else if($3->type==tdouble && $1->type!=tstring && \
			$1->type!=tboolean && $1->type!=tnull && $1->type!=tvoid && $1->type!=tnone)
				$$->type=tdouble;
			else if($3->type==tfloat && $1->type!=tdouble && $1->type!=tstring && $1->type!=tboolean \
			&& $1->type!=tnull && $1->type!=tvoid && $1->type!=tnone) 
				$$->type=tfloat;
			else if($3->type==tlong && ($1->type==tlong || \
			$1->type==tint || $1->type==tbyte || $1->type==tshort || $1->type==tchar))
                        	$$->type=tlong;
                	else if($3->type==tint && ($1->type==tint || $1->type==tbyte || $1->type==tshort || $1->type==tchar))
                        	$$->type=tint;
                	else if($3->type==tshort && ($1->type==tbyte || $1->type==tshort))
                        	$$->type=tshort;
                	else if($3->type==tbyte && $1->type==tbyte)
                        	$$->type=tbyte;
                	else if($3->type==tchar && $1->type==tchar)
                        	$$->type=tchar;
			else if($1->type==tboolean && $3->type==tboolean)
				$$->type=tboolean;
                	else
                	{
                        	printf("ERROR:Incorrect initialisation line %d\n",yylineno);
                        	$$->type=tnone;
                	}
		}
		else if(!($1->token==1 || $3->token==1 || $1->token==3 || $3->token==3))
		{
			$$->token=$1->token;
			$$->dimension=$1->dimension;
			if($1->dimension!=$3->dimension)
			{
				$$->type=tnone;
				printf("ERROR:array dimension mismatch at line %d\n",yylineno);
			}
			else if(strcmp($1->ref,$3->ref)!=0)
			{
				printf("ERROR:Incorrect initialisation at line %d\n",yylineno);
				$$->type=tnone;
			}
			else
				strcpy($$->ref,$1->ref);
		}
		else
		{
			$$->type=tnone;
			printf("ERROR:Incorrect initialisation at line %d\n",yylineno);
		}
	}
;

MethodDeclaration:
	MethodHeader
	{	
		int i=0;
		bool found=false;
		vector<methodConstructor *> temp=listOfClasses[currenterpointer].listOfMethods;
		for(;i<temp.size();i++)
		{
			if(!strcmp(temp[i]->name,m->name))
			{
				if(temp[i]->param.size()==m->param.size())
				{
					int j;
					for(j=0;j<temp[i]->param.size();j++)
					{
						if(temp[i]->param[j]->token!=m->param[j]->token)
							break;
						else if(temp[i]->param[j]->dimension!=m->param[j]->dimension)
							break;
						else if(temp[i]->param[j]->token==1 || temp[i]->param[j]->token==3)
						{
							if(temp[i]->param[j]->type!=m->param[j]->type)
								break;
						}
						else if(strcmp(temp[i]->param[j]->ref,m->param[j]->ref))
							break;
					}
					if(j==temp[i]->param.size())
					{
						found=true;
						break;
					}
				}
			}
		}
		if(!found)
		{
			listOfClasses[currenterpointer].listOfMethods.push_back(m);printf("function %s installed\n",m->name);
			if(!strcmp(m->name,"main"))
				fprintf(fcg,"main:\n");
			else
				fprintf(fcg,"%s%d:\n",m->name,method_count++);
			fprintf(fcg,"subu $sp,$sp,352\n");//variable method length??
			fprintf(fcg,"sw $ra,40($sp)\n");
			fprintf(fcg,"sw $fp,36($sp)\n");
			fprintf(fcg,"addu $fp,$sp,300\n");
			fprintf(fcg,"s.s $f12,32($sp)\n");
			fprintf(fcg,"s.s $f13,28($sp)\n");
			fprintf(fcg,"s.s $f14,24($sp)\n");
			fprintf(fcg,"sw $a0,20($sp)\n");
			fprintf(fcg,"sw $a1,16($sp)\n");
			fprintf(fcg,"sw $a2,12($sp)\n");
			fprintf(fcg,"sw $a3,8($sp)\n\n");			
		}
		else
			printf("ERROR line %d:function  already installled\n",yylineno);
	}MethodBody
	{	
		removetable(currenter);
		if(returninfo->type!=tvoid && !returnFound)
			printf("ERROR:expected return statement\n");
		if(strcmp(m->name,"main"))
		{
			fprintf(fcg,"%s%dend:\n",m->name,method_count-1);
			fprintf(fcg,"lw $ra,40($sp)\n");
			fprintf(fcg,"lw $fp,36($sp)\n");
			fprintf(fcg,"l.s $f12,32($sp)\n");
			fprintf(fcg,"l.s $f13,28($sp)\n");
			fprintf(fcg,"l.s $f14,24($sp)\n");
			fprintf(fcg,"lw $a0,20($sp)\n");
			fprintf(fcg,"lw $a1,16($sp)\n");
			fprintf(fcg,"lw $a2,12($sp)\n");
			fprintf(fcg,"lw $a3,8($sp)\n");	
			fprintf(fcg,"addu $sp,$sp,352\n");
			fprintf(fcg,"jr $ra\n\n");
			num_var=3;
		}	
		else
		{
			fprintf(fcg,"\nmainend:\n");
			fprintf(fcg,"li $v0,10\n");
			fprintf(fcg,"syscall\n");
			num_var=3;
		}
		returnFound=false;
	}
;
MethodHeader:	/*ensure the correct kind of modifiers*/
	Modifiers VOID MethodDeclarator
	{
		createtable(currenter);	
		m = (struct methodConstructor *)malloc(sizeof(methodConstructor));
		returninfo=(struct attribute *)malloc(sizeof(struct attribute));
		returninfo->type=tvoid;
		returninfo->modifier=listOfModifiers;
		strcpy(m->name,id);
		m->number=method_count;
                m->modifier=listOfModifiers;
		listOfModifiers.clear();
                m->type=tvoid;
		m->token=1;
		returninfo->token=1;
		returninfo->dimension=0;
		m->param=param;
		int i,nonfloat=0,fl=0;
		for(i=0;i<param.size();i++)
		{
			if(findentry(currenter,param[i]->value))	
				printf("ERROR:redefinition of variable %s at line %d\n",param[i]->value,yylineno);
			else
			{
				if(param[i]->token==1 || param[i]->token==3)
				{
					if((param[i]->type==tfloat || param[i]->type==tdouble) && param[i]->token==1)
						insertentry(currenter,param[i]->value,param[i]->modifier,param[i]->type,NULL,param[i]->dimension,105+fl++);
					else
						insertentry(currenter,param[i]->value,param[i]->modifier,param[i]->type,NULL,param[i]->dimension,100+nonfloat++);
				}
				else if(param[i]->token==2 || param[i]->token==4)
					insertentry(currenter,param[i]->value,param[i]->modifier,tnone,param[i]->ref,param[i]->dimension,100+nonfloat++);
			}
		}			
		param.clear();
	} 
	|
	VOID MethodDeclarator
	{	createtable(currenter);
		m = (struct methodConstructor *)malloc(sizeof(methodConstructor));
		returninfo=(struct attribute *)malloc(sizeof(struct attribute));
		returninfo->type=tvoid;
		returninfo->token=2;
		returninfo->dimension=0;
		strcpy(m->name,id);
		m->number=method_count;
                m->type=tvoid;
		m->token=1;
		m->modifier.push_back(mnative);
		m->param=param;
		int i,nonfloat=0,fl=0;
		for(i=0;i<param.size();i++)
		{
			if(findentry(currenter,param[i]->value))	
				printf("ERROR:redefinition of variable %s at line %d\n",id,yylineno); 
			else
			{
				printf("installing %s in the symbol table %p\n",param[i]->value,currenter);
				if(param[i]->token==1 || param[i]->token==3)
				{
					if((param[i]->type==tfloat || param[i]->type==tdouble) && param[i]->token==1)
						insertentry(currenter,param[i]->value,param[i]->modifier,param[i]->type,NULL,param[i]->dimension,105+fl++);
					else
						insertentry(currenter,param[i]->value,param[i]->modifier,param[i]->type,NULL,param[i]->dimension,100+nonfloat++);
				}
				else if(param[i]->token==2 || param[i]->token==4)
					insertentry(currenter,param[i]->value,param[i]->modifier,tnone,param[i]->ref,param[i]->dimension,100+i);
			}
		}			
		param.clear();
	}
	|
	Modifiers Type MethodDeclarator
	{	createtable(currenter);
		m = (struct methodConstructor *)malloc(sizeof(methodConstructor));
		returninfo=(struct attribute *)malloc(sizeof(struct attribute));
		returninfo->modifier=listOfModifiers;
		strcpy(m->name,id);
		m->number=method_count;
                m->modifier=listOfModifiers;
		listOfModifiers.clear();
		returninfo->dimension=0;
                if($2->token==1 || $2->token==3)
		{
			returninfo->type=$2->type;
			returninfo->token=1;
                        m->type=$2->type;
			m->token=1;
		}
                else
		{
			strcpy(returninfo->ref,$2->ref);
                        strcpy(m->ref,$2->ref);
			m->token=2;
			returninfo->token=2;
		}
		m->param=param;
		int i,nonfl=0,fl=0;
		for(i=0;i<param.size();i++)
		{
			if(findentry(currenter,param[i]->value))	
				printf("ERROR:redefinition of variable %s at line %d\n",id,yylineno); 
			else
			{
				printf("installing %s in the symbol table %p\n",param[i]->value,currenter);
				if(param[i]->token==1 || param[i]->token==3)
				{
					if((param[i]->type==tfloat || param[i]->type==tdouble) && param[i]->token==1)
						insertentry(currenter,param[i]->value,param[i]->modifier,param[i]->type,NULL,param[i]->dimension,105+fl++);
					else
						insertentry(currenter,param[i]->value,param[i]->modifier,param[i]->type,NULL,param[i]->dimension,100+nonfl++);
				}
				else if(param[i]->token==2 || param[i]->token==4)
					insertentry(currenter,param[i]->value,param[i]->modifier,tnone,param[i]->ref,param[i]->dimension,100+nonfl++);
			}
		}			
		param.clear();
	}
	|
	Type MethodDeclarator 
	{	createtable(currenter);
		m = (struct methodConstructor *)malloc(sizeof(methodConstructor));
		returninfo=(struct attribute *)malloc(sizeof(struct attribute));
		strcpy(m->name,id);
		m->number=method_count;
		returninfo->dimension=0;
		m->modifier.push_back(mnative);
                if($1->token==1)
		{
			returninfo->type=$1->type;
			returninfo->token=1;
                        m->type=$1->type;
			m->token=1;
		}
                else
		{
			strcpy(returninfo->ref,$1->ref);
                        strcpy(m->ref,$1->ref);
			m->token=2;
			returninfo->token=2;
		}
		m->param=param;
		int i,nonfl=0,fl=0;
		for(i=0;i<param.size();i++)
		{
			if(findentry(currenter,param[i]->value))	
				printf("ERROR:redefinition of variable %s at line %d\n",id,yylineno); 
			else
			{
				printf("installing %s in the symbol table %p\n",param[i]->value,currenter);
				if(param[i]->token==1 || param[i]->token==3)
				{
					if((param[i]->type==tfloat || param[i]->type==tdouble) && param[i]->token==1)
						insertentry(currenter,param[i]->value,param[i]->modifier,param[i]->type,NULL,param[i]->dimension,105+fl++);
					else
						insertentry(currenter,param[i]->value,param[i]->modifier,param[i]->type,NULL,param[i]->dimension,100+nonfl++);
				}
				else if(param[i]->token==2 || param[i]->token==4)
					insertentry(currenter,param[i]->value,param[i]->modifier,tnone,param[i]->ref,param[i]->dimension,100+nonfl++);
			}
		}			
		param.clear();
	}
;
MethodDeclarator:
	Identifier LRBRACE FormalParameterList {strcpy(id,$1);} RRBRACE
	|
	Identifier LRBRACE{strcpy(id,$1);} RRBRACE
	|
	Identifier error FormalParameterList RRBRACE		{printf("ERROR:Missing ( on line %d\n",yylineno);}
	|
	Identifier error RRBRACE 				{printf("ERROR:Missing ( on line %d\n",yylineno);}
	|
	Identifier LRBRACE error SEMICOLON			{printf("ERROR:Missing ) on line %d\n",yylineno);}
	|
	Identifier LRBRACE FormalParameterList error SEMICOLON 	{printf("ERROR:Missing ) on line %d\n",yylineno);}
;
FormalParameterList:
	LastFormalParameter
	|
	FormalParameters COMMA LastFormalParameter
;

FormalParameters:
	FormalParameter
	|
	FormalParameters COMMA FormalParameter
	|
	FormalParameters COMMA error
;

FormalParameter:
	FINAL Type VariableDeclaratorID
	{
		struct attribute *temp=(struct attribute *)malloc(sizeof(struct attribute));
		temp->dimension=typeinfo->dimension+$3->dimension;
		temp->modifier.push_back(mfinal);
		strcpy(temp->value,id);
		if(typeinfo->token==1 || typeinfo->token==3)
		{
			temp->type=typeinfo->type;
			temp->token=temp->dimension>0?3:1;
		}
		else
		{
			strcpy(temp->ref,typeinfo->ref);
			temp->token=temp->dimension>0?4:2;
		}
		strcpy(temp->value,id);
		param.push_back(temp);
	}
	|
	Type VariableDeclaratorID 
	{
		struct attribute *temp=(struct attribute *)malloc(sizeof(struct attribute));
		temp->dimension=typeinfo->dimension+$2->dimension;
		temp->modifier.push_back(mpublic);
		strcpy(temp->value,id);
                if(typeinfo->token==1 || typeinfo->token==3)
		{
			temp->type=typeinfo->type;
			temp->token=temp->dimension>0?3:1;
		}
		else
		{
			strcpy(temp->ref,typeinfo->ref);
			temp->token=temp->dimension>0?4:2;
		}
		strcpy(temp->value,id);
                param.push_back(temp);
	}
;

LastFormalParameter:
	FINAL Type DOT DOT DOT VariableDeclaratorID
	{
		struct attribute *temp=(struct attribute *)malloc(sizeof(struct attribute));
                temp->modifier.push_back(mfinal);
		temp->dimension=typeinfo->dimension+$6->dimension;
		strcpy(temp->value,id);
                if(typeinfo->token==1 || typeinfo->token==3)
		{
			temp->type=typeinfo->type;
			temp->token=temp->dimension>0?3:1;
		}
		else
		{
			strcpy(temp->ref,typeinfo->ref);
			temp->token=temp->dimension>0?4:2;
		}
		strcpy(temp->value,id);
                param.push_back(temp);
	}
	|
	Type DOT DOT DOT VariableDeclaratorID
	{
		struct attribute *temp=(struct attribute *)malloc(sizeof(struct attribute));
		temp->modifier.push_back(mpublic);
		temp->dimension=typeinfo->dimension+$5->dimension;
		strcpy(temp->value,id);
                if(typeinfo->token==1 || typeinfo->token==3)
		{
			temp->type=typeinfo->type;
			temp->token=temp->dimension>0?3:1;
		}
		else
		{
			strcpy(temp->ref,typeinfo->ref);
			temp->token=temp->dimension>0?4:2;
		}
		strcpy(temp->value,id);
                param.push_back(temp);
	}
	|
	FormalParameter
;
MethodBody:
	Block
	|
	SEMICOLON
;
ConstructorDeclaration:
	Modifiers ConstructorDeclarator ConstructorBody
	{
		removetable(currenter);
		int i=0;
		bool found=false;
		returninfo->modifier=listOfModifiers;
		listOfModifiers.clear();
		vector<methodConstructor *> temp=listOfClasses[currenterpointer].listOfMethods;
		for(;i<temp.size();i++)
		{
			if(!strcmp(temp[i]->name,m->name))
			{
				if(temp[i]->param.size()==m->param.size())
				{
					int j;
					for(j=0;j<temp[i]->param.size();j++)
					{
						if(temp[i]->param[j]->token!=m->param[j]->token)
							break;
						else if(temp[i]->param[j]->dimension!=m->param[j]->dimension)
							break;
						else if(temp[i]->param[j]->token==1 || temp[i]->param[j]->token==3)
						{
							if(temp[i]->param[j]->type!=m->param[j]->type)
								break;
						}
						else if(strcmp(temp[i]->param[j]->ref,m->param[j]->ref))
							break;
					}
					if(j==temp[i]->param.size())
					{
						found=true;
						break;
					}
				}
			}
		}
		if(!found)
		{
			listOfClasses[currenterpointer].listOfMethods.push_back(m);
			printf("constructor installed\n");
			fprintf(fcg,"%s%dend:\n",m->name,method_count-1);
			fprintf(fcg,"lw $ra,40($sp)\n");
			fprintf(fcg,"lw $fp,36($sp)\n");
			fprintf(fcg,"l.s $f12,32($sp)\n");
			fprintf(fcg,"l.s $f13,28($sp)\n");
			fprintf(fcg,"l.s $f14,24($sp)\n");
			fprintf(fcg,"lw $a0,20($sp)\n");
			fprintf(fcg,"lw $a1,16($sp)\n");
			fprintf(fcg,"lw $a2,12($sp)\n");
			fprintf(fcg,"lw $a3,8($sp)\n");	
			fprintf(fcg,"addu $sp,$sp,352\n");
			fprintf(fcg,"jr $ra\n\n");
			num_var=3;
		}
		else
			printf("ERROR line %d:constructor already installled\n",yylineno);
	}	
	|
	ConstructorDeclarator ConstructorBody
	{
		removetable(currenter);
		int i=0;
		returninfo->modifier.push_back(mnative);
		bool found=false;
		vector<methodConstructor *> temp=listOfClasses[currenterpointer].listOfMethods;
		for(;i<temp.size();i++)
		{
			if(!strcmp(temp[i]->name,m->name))
			{
				if(temp[i]->param.size()==m->param.size())
				{
					int j;
					for(j=0;j<temp[i]->param.size();j++)
					{
						if(temp[i]->param[j]->token!=m->param[j]->token)
							break;
						else if(temp[i]->param[j]->dimension!=m->param[j]->dimension)
							break;
						else if(temp[i]->param[j]->token==1 || temp[i]->param[j]->token==3)
						{
							if(temp[i]->param[j]->type!=m->param[j]->type)
								break;
						}
						else if(strcmp(temp[i]->param[j]->ref,m->param[j]->ref))
							break;
					}
					if(j==temp[i]->param.size())
					{
						found=true;
						break;
					}
				}
			}
		}
		if(!found)
		{
			listOfClasses[currenterpointer].listOfMethods.push_back(m);
			printf("constructor installed\n");
			fprintf(fcg,"%s%dend:\n",m->name,method_count-1);
			fprintf(fcg,"lw $ra,40($sp)\n");
			fprintf(fcg,"lw $fp,36($sp)\n");
			fprintf(fcg,"l.s $f12,32($sp)\n");
			fprintf(fcg,"l.s $f13,28($sp)\n");
			fprintf(fcg,"l.s $f14,24($sp)\n");
			fprintf(fcg,"lw $a0,20($sp)\n");
			fprintf(fcg,"lw $a1,16($sp)\n");
			fprintf(fcg,"lw $a2,12($sp)\n");
			fprintf(fcg,"lw $a3,8($sp)\n");	
			fprintf(fcg,"addu $sp,$sp,352\n");
			fprintf(fcg,"jr $ra\n\n");
			num_var=3;
		}
		else
			printf("ERROR line %d:constructor already installled\n",yylineno);
	}	
	|
	ConstructorDeclarator error			{printf("ERROR:Error in constructor body,line %d\n",yylineno);}
;
ConstructorDeclarator:
	SimpleName LRBRACE FormalParameterList RRBRACE 
	{	createtable(currenter);
		m=(struct methodConstructor *)malloc(sizeof(methodConstructor));
		if(listOfModifiers.size()==0)
			m->modifier.push_back(mnative);
		else
			m->modifier=listOfModifiers;
		m->number=method_count;
		returninfo=(struct attribute *)malloc(sizeof(struct attribute));
		returninfo->type=tvoid;
		listOfModifiers.clear();
		ClassInterface *t=new ClassInterface;
		t=&listOfClasses[currenterpointer];
		while(t!=NULL)
		{
			if(!strcmp($1,t->name))
				break;
			else
				t=t->extends;
		}
		if(!t)
		{
			strcpy(m->name,"012");
			printf("ERROR:Incorrect constructor declaration at line %d\n",yylineno);
		}
		else
		{
			m->param=param;
			int i,nonfloat=0,fl=0;
			for(i=0;i<param.size();i++)
			{
				if(findentry(currenter,param[i]->value))	
					printf("ERROR:redefinition of variable %s at line %d\n",param[i]->value,yylineno);
				else
				{
					if(param[i]->token==1 || param[i]->token==3)
					{
						if((param[i]->type==tfloat || param[i]->type==tdouble) && param[i]->token==1)
							insertentry(currenter,param[i]->value,param[i]->modifier,param[i]->type,NULL,param[i]->dimension,105+fl++);
						else
							insertentry(currenter,param[i]->value,param[i]->modifier,param[i]->type,NULL,param[i]->dimension,100+nonfloat++);
					}
					else if(param[i]->token==2 || param[i]->token==4)
						insertentry(currenter,param[i]->value,param[i]->modifier,tnone,param[i]->ref,param[i]->dimension,100+nonfloat++);
				}
			}			
			strcpy(m->name,$1);
			fprintf(fcg,"%s%d:\n",m->name,method_count++);
			fprintf(fcg,"subu $sp,$sp,352\n");//variable method length??
			fprintf(fcg,"sw $ra,40($sp)\n");
			fprintf(fcg,"sw $fp,36($sp)\n");
			fprintf(fcg,"addu $fp,$sp,300\n");
			fprintf(fcg,"s.s $f12,32($sp)\n");
			fprintf(fcg,"s.s $f13,28($sp)\n");
			fprintf(fcg,"s.s $f14,24($sp)\n");
			fprintf(fcg,"sw $a0,20($sp)\n");
			fprintf(fcg,"sw $a1,16($sp)\n");
			fprintf(fcg,"sw $a2,12($sp)\n");
			fprintf(fcg,"sw $a3,8($sp)\n\n");			
		}
		param.clear();
	}
	|
	SimpleName LRBRACE RRBRACE
	{	 createtable(currenter);
		 m=(struct methodConstructor *)malloc(sizeof(methodConstructor));
		 if(listOfModifiers.size()==0)
			m->modifier.push_back(mnative);
		 else
			m->modifier=listOfModifiers; 
		 m->number=method_count;
                 listOfModifiers.clear();
		 ClassInterface *t=new ClassInterface;
		 t=&listOfClasses[currenterpointer];
		 returninfo=(struct attribute *)malloc(sizeof(struct attribute));
		 returninfo->type=tvoid;
		 while(t!=NULL)
		 {
			if(!strcmp($1,t->name))
				break;
			else
				t=NULL;
		}
		if(!t)
		{
			strcpy(m->name,"012");
			printf("ERROR:Incorrect constructor declaration at line %d\n",yylineno);
		}
                else
		{
			strcpy(m->name,$1);
			fprintf(fcg,"%s%d:\n",m->name,method_count++);
			fprintf(fcg,"subu $sp,$sp,352\n");//variable method length??
			fprintf(fcg,"sw $ra,40($sp)\n");
			fprintf(fcg,"sw $fp,36($sp)\n");
			fprintf(fcg,"addu $fp,$sp,300\n");
			fprintf(fcg,"s.s $f12,32($sp)\n");
			fprintf(fcg,"s.s $f13,28($sp)\n");
			fprintf(fcg,"s.s $f14,24($sp)\n");
			fprintf(fcg,"sw $a0,20($sp)\n");
			fprintf(fcg,"sw $a1,16($sp)\n");
			fprintf(fcg,"sw $a2,12($sp)\n");
			fprintf(fcg,"sw $a3,8($sp)\n\n");
		}			
	}
	|
	SimpleName LRBRACE error SEMICOLON			{printf("ERROR:Missing ) on line %d\n",yylineno);}
;
ConstructorBody:
	LCBRACE ExplicitConstructorInvocation BlockStatements RCBRACE
	|
	Block
	|
	LCBRACE ExplicitConstructorInvocation RCBRACE
;
ExplicitConstructorInvocation:
	THIS LRBRACE ArgumentList RRBRACE SEMICOLON
	{
		struct ClassInterface *t=(struct ClassInterface *)malloc(sizeof(struct ClassInterface));
		struct methodConstructor *m1=new struct methodConstructor;
		t=&listOfClasses[currenterpointer];
		int p=currenterpointer;
		while(p>=0)
		{
			t=&listOfClasses[p];
			if(!strcmp(t->name,m->name))
				break;
			else
				p--;
		}
		bool found=false;
		int j;
		for(j=0;j<t->listOfMethods.size() && !found;j++)
		{
			if(strcmp(t->listOfMethods[j]->name,t->name)==0 && t->listOfMethods[j]->param.size()==param.size())
			{
				m1=t->listOfMethods[j];
				found=compare(t->listOfMethods[j]->param,param);	
			}
		}
		if(!found)
			printf("ERROR:Illegal constructor invocation at line %d\n",yylineno);
		else
		{
			int nonfloat=0,fl=12;
			for(j=0;j<param.size();j++)		//currently restrciting to only 4 parameters
			{
				char *val=Address(param[j]->contains);
				if(m1->param[j]->type==tfloat || m1->param[j]->type==tdouble)
				{
					if(param[j]->type!=tfloat && param[j]->type!=tdouble)
					{
						if(Ref(val)==constant)
							fprintf(fcg,"li $t0,%s\n",val);
						else if(Ref(val)==memory)
							fprintf(fcg,"lw $t0,%s\n",val);
						else
							fprintf(fcg,"move $t0,%s\n",val);
						fprintf(fcg,"mtc1 $t0,$f1\n");
						fprintf(fcg,"cvt.s.w $f1,$f1\n");
						fprintf(fcg,"mov.s $f%d,$f1\n",fl++);
					}
					else
					{
						if(Ref(val)==constant)
							fprintf(fcg,"li.s $f%d,%s\n",fl++,val);
						else if(Ref(val)==memory)
							fprintf(fcg,"l.s $f%d,%s\n",fl++,val);
						else
							fprintf(fcg,"mov.s $f%d,%s\n",fl++,val);
					}	
				}
				else
				{
					if(Ref(val)==constant)
						fprintf(fcg,"li $a%d,%s\n",nonfloat++,val);
					else if(Ref(val)==memory)
						fprintf(fcg,"lw $a%d,%s\n",nonfloat++,val);
					else
						fprintf(fcg,"move $a%d,%s\n",nonfloat++,val);
				}
			}
			fprintf(fcg,"\njal %s%d\n",m1->name,m1->number);
		}
		param.clear();
	}
	|
	THIS LRBRACE RRBRACE SEMICOLON
	{
		struct ClassInterface *t=(struct ClassInterface *)malloc(sizeof(struct ClassInterface));
		struct methodConstructor *m1=new struct methodConstructor;
		t=&listOfClasses[currenterpointer];
		int p=currenterpointer;
		while(p>=0)
		{
			t=&listOfClasses[p];
			if(!strcmp(t->name,m->name))
				break;
			else
				p--;
		}
		bool found=false;
		int j;
		for(int j=0;j<t->listOfMethods.size() && !found;j++)
		{
			if(strcmp(t->listOfMethods[j]->name,t->name)==0 && t->listOfMethods[j]->param.size()==0)
			{
				m1=t->listOfMethods[j];
				found=true;
			}
		}
		if(!found)
			printf("ERROR:Illegal constructor invocation at line %d\n",yylineno);
		else
			fprintf(fcg,"\njal %s%d\n",m1->name,m1->number);
	}
	|
	SUPER LRBRACE ArgumentList RRBRACE SEMICOLON
	{
		struct ClassInterface *t=(struct ClassInterface *)malloc(sizeof(struct ClassInterface));
		struct methodConstructor *m1=new struct methodConstructor;
		t=&listOfClasses[currenterpointer];
		int p=currenterpointer;
		while(p>=0)
		{
			t=&listOfClasses[p];
			if(!strcmp(t->name,m->name))
				break;
			else
				p--;
		}
		if(t->extends==NULL)
			printf("ERROR:no super class found\n");
		t=t->extends;
		bool found=false;
		int j;
		if(t!=NULL)
		{
			for(j=0;j<t->listOfMethods.size() && !found;j++)
			{
				//printf("%d %d\n",param.size(),t->listOfMethods[j]->param.size());
				if(strcmp(t->listOfMethods[j]->name,t->name)==0 && t->listOfMethods[j]->param.size()==param.size())
				{
					m1=t->listOfMethods[j];
					found=compare(t->listOfMethods[j]->param,param);
				}
			}
		}
		if(!found)
			printf("ERROR:Illegal constructor invocation at line %d\n",yylineno);
		else
		{
			int nonfloat=0,fl=12;
			for(j=0;j<param.size();j++)		//currently restrciting to only 4 parameters
			{
				char *val=Address(param[j]->contains);
				if(m1->param[j]->type==tfloat || m1->param[j]->type==tdouble)
				{
					if(param[j]->type!=tfloat && param[j]->type!=tdouble)
					{
						if(Ref(val)==constant)
							fprintf(fcg,"li $t0,%s\n",val);
						else if(Ref(val)==memory)
							fprintf(fcg,"lw $t0,%s\n",val);
						else
							fprintf(fcg,"move $t0,%s\n",val);
						fprintf(fcg,"mtc1 $t0,$f1\n");
						fprintf(fcg,"cvt.s.w $f1,$f1\n");
						fprintf(fcg,"mov.s $f%d,$f1\n",fl++);
					}
					else
					{
						if(Ref(val)==constant)
							fprintf(fcg,"li.s $f%d,%s\n",fl++,val);
						else if(Ref(val)==memory)
							fprintf(fcg,"l.s $f%d,%s\n",fl++,val);
						else
							fprintf(fcg,"mov.s $f%d,%s\n",fl++,val);
						}	
				}
				else
				{
					if(Ref(val)==constant)
						fprintf(fcg,"li $a%d,%s\n",nonfloat++,val);
					else if(Ref(val)==memory)
						fprintf(fcg,"lw $a%d,%s\n",nonfloat++,val);
					else
						fprintf(fcg,"move $a%d,%s\n",nonfloat++,val);
				}
			}
			fprintf(fcg,"\njal %s%d\n",m1->name,m1->number);
		}
		param.clear();
	}
	|
	SUPER LRBRACE RRBRACE SEMICOLON
	{
		struct ClassInterface *t=(struct ClassInterface *)malloc(sizeof(struct ClassInterface));
		struct methodConstructor *m1=new struct methodConstructor;
		t=&listOfClasses[currenterpointer];
		int p=currenterpointer;
		while(p>=0)
		{
			t=&listOfClasses[p];
			if(!strcmp(t->name,m->name))
				break;
			else
				p--;
		}
		if(t->extends==NULL)
			printf("ERROR:no super class found\n");
		t=t->extends;
		bool found=false;
		if(t!=NULL)
		{
			for(int j=0;j<t->listOfMethods.size() && !found;j++)
			{
				if(strcmp(t->listOfMethods[j]->name,t->name)==0 && t->listOfMethods[j]->param.size()==0)
				{
					m1=t->listOfMethods[j];
					found=true;
				}
			}
		}
		if(!found)
			printf("ERROR:Illegal constructor invocation at line %d\n",yylineno);
		else
			fprintf(fcg,"\njal %s%d\n",m1->name,m1->number);
	}
	|
        THIS LRBRACE ArgumentList error SEMICOLON
        |
        THIS LRBRACE error SEMICOLON
        |
        SUPER LRBRACE ArgumentList error SEMICOLON
        |
        SUPER LRBRACE error SEMICOLON
;

EnumDeclaration:
	Modifiers ENUM Identifier Interfaces EnumBody
	|
	ENUM Identifier Interfaces EnumBody
	|
	Modifiers ENUM Identifier EnumBody
	|
	ENUM Identifier EnumBody
	|
	ENUM error EnumBody
	|
	Modifiers ENUM error EnumBody
;
EnumBody:
	LCBRACE EnumConstants COMMA EnumBodyDeclarations RCBRACE
	|
	LCBRACE EnumConstants EnumBodyDeclarations RCBRACE
	|
	LCBRACE COMMA EnumBodyDeclarations RCBRACE
	|
	LCBRACE EnumConstants COMMA RCBRACE
	|
	LCBRACE EnumBodyDeclarations RCBRACE
	|
	LCBRACE EnumConstants RCBRACE
	|
	LCBRACE COMMA RCBRACE
	|
	LCBRACE RCBRACE
	|
	LCBRACE EnumConstants COMMA EnumBodyDeclarations error SEMICOLON	{printf("ERROR:Missing } on line %d\n",yylineno);}
        |
        LCBRACE EnumConstants EnumBodyDeclarations error SEMICOLON		{printf("ERROR:Missing } on line %d\n",yylineno);}
        |
        LCBRACE COMMA EnumBodyDeclarations error SEMICOLON			{printf("ERROR:Missing } on line %d\n",yylineno);}
        |
        LCBRACE EnumConstants COMMA error SEMICOLON				{printf("ERROR:Missing } on line %d\n",yylineno);}
        |
        LCBRACE EnumBodyDeclarations error SEMICOLON				{printf("ERROR:Missing } on line %d\n",yylineno);}
        |
        LCBRACE EnumConstants error SEMICOLON					{printf("ERROR:Missing } on line %d\n",yylineno);}
        |
        LCBRACE COMMA error SEMICOLON						{printf("ERROR:Missing } on line %d\n",yylineno);}
        |
        LCBRACE error SEMICOLON							{printf("ERROR:Missing } on line %d\n",yylineno);}
;
EnumConstants:
	EnumConstant
	|
	EnumConstants COMMA EnumConstant
;
EnumConstant:
	Identifier Arguments ClassBody
	|
	Identifier ClassBody
	|
	Identifier Arguments
	|
	Identifier
;
EnumBodyDeclarations:
	SEMICOLON ClassBodyDeclarations
	|
	SEMICOLON
;
Arguments:
	LRBRACE ArgumentList RRBRACE
	|
	LRBRACE RRBRACE
	|
	LRBRACE error RRBRACE
;
InterfaceDeclaration:
	Modifiers INTERFACE Identifier EXTENDS InterfaceTypeList 
	{
		 for(int i=0;i<listOfModifiers.size();i++) {
                 if(!(listOfModifiers[i]==mpublic||listOfModifiers[i]==mprivate||listOfModifiers[i]==mprotected||listOfModifiers[i]==mabstract||listOfModifiers[i]==mstatic||listOfModifiers[i]==mstrictfp ))
                                printf("ERROR:Incorrect modifier at line %d\n",yylineno);}
                 currenterpointer++;
                 createtable(currenter);
                 ClassInterface cl;
                 strcpy(cl.name,$3);
                 cl.table=(ST *)malloc(sizeof(ST));
                 cl.extends=(ClassInterface *)malloc(sizeof(ClassInterface));
		 cl.implements=NULL;
                 cl.table=currenter;
                 int i;
                 for(i=0;i<listOfClasses.size();i++)
                 {
                       if(strcmp(listOfClasses[i].name,$5->ref)==0)
                                        break;
                 }
                 if(i==listOfClasses.size())
		 {
			cl.extends=NULL;
                        printf("ERROR:Error in class declaration.No class/interface of name %s found\n",$5->ref);
		 }
                 else
                       *(cl.extends)=listOfClasses[i];
                 cl.modifiers=listOfModifiers;
                 listOfModifiers.clear();
                 
                	for(i=0;i<listOfClasses.size();i++)
                	{
                                if(strcmp(listOfClasses[i].name,cl.name)==0)
                                        break;
                        }
			if(i==listOfClasses.size())
                        	listOfClasses.push_back(cl);
			else
			{
				currenterpointer--;
				printf("ERROR:Multiple definition of class %s on line %d\n",cl.name,yylineno);
			}
	}InterfaceBody{currenter=NULL;}
	|
	INTERFACE Identifier EXTENDS InterfaceTypeList 
	{
		 currenterpointer++;
                 createtable(currenter);
                 ClassInterface cl;
                 strcpy(cl.name,$2);
                 cl.table=(ST *)malloc(sizeof(ST));
                 cl.table=currenter;
                 cl.extends=(ClassInterface *)malloc(sizeof(ClassInterface));
		 cl.implements=NULL;
                 int i;
                 for(i=0;i<listOfClasses.size();i++)
                 {
                       if(strcmp(listOfClasses[i].name,$4->ref)==0)
                                        break;
                 }
                 if(i==listOfClasses.size())
		 {
			cl.extends=NULL;
                        printf("ERROR:Error in class declaration.No class/interface of name %s found\n",$4->ref);
		 }
                 else
                                *(cl.extends)=listOfClasses[i];
                 cl.modifiers.push_back(mnative);
                 
                	for(i=0;i<listOfClasses.size();i++)
                	{
                                if(strcmp(listOfClasses[i].name,cl.name)==0)
                                        break;
                        }
			if(i==listOfClasses.size())
                        	listOfClasses.push_back(cl);
			else
			{
				currenterpointer--;
				printf("ERROR:Multiple definition of class %s on line %d\n",cl.name,yylineno);
			}
	}InterfaceBody{currenter=NULL;}
	|
	Modifiers INTERFACE Identifier 
	{
		for(int i=0;i<listOfModifiers.size();i++) {
                if(!(listOfModifiers[i]==mpublic||listOfModifiers[i]==mprivate||listOfModifiers[i]==mprotected||listOfModifiers[i]==mabstract||listOfModifiers[i]==mstatic||listOfModifiers[i]==mstrictfp ))
                                printf("ERROR:Incorrect modifier at line %d\n",yylineno);}
                 currenterpointer++;
                 createtable(currenter);
                 ClassInterface cl;
                 strcpy(cl.name,$3);
                 cl.table=(ST *)malloc(sizeof(ST));
                 cl.table=currenter;
                 cl.modifiers=listOfModifiers;
		 cl.extends=NULL;
		 cl.implements=NULL;
                 listOfModifiers.clear();
                 int i;
                for(i=0;i<listOfClasses.size();i++)
                {
                                if(strcmp(listOfClasses[i].name,cl.name)==0)
                                        break;
                }
		if(i==listOfClasses.size())
                        	listOfClasses.push_back(cl);
		else
		{currenterpointer--;printf("ERROR:Multiple definition of class %s on line %d\n",cl.name,yylineno);}
	}InterfaceBody{currenter=NULL;}
	|
	INTERFACE Identifier 
	{
                 currenterpointer++;
                 createtable(currenter);
                 ClassInterface cl;
                 strcpy(cl.name,$2);
                 cl.table=(ST *)malloc(sizeof(ST));
                 cl.table=currenter;
		 cl.implements=NULL;
		 cl.extends=NULL;
		 cl.modifiers.push_back(mnative);
                 int i;
                	for(i=0;i<listOfClasses.size();i++)
                	{
                                if(strcmp(listOfClasses[i].name,cl.name)==0)
                                        break;
                        }
			if(i==listOfClasses.size())
                        	listOfClasses.push_back(cl);
			else
			{currenterpointer--;printf("ERROR:Multiple definition of class %s on line %d\n",cl.name,yylineno);}
	}InterfaceBody{currenter=NULL;}
	|
	Modifiers INTERFACE error InterfaceBody
	|
	INTERFACE error InterfaceBody
;
InterfaceBody:
	LCBRACE InterfaceMemberDeclarations RCBRACE
	|
	LCBRACE RCBRACE  
;
InterfaceMemberDeclarations:
	InterfaceMemberDeclaration
	|
	InterfaceMemberDeclarations InterfaceMemberDeclaration
;
InterfaceMemberDeclaration:
	FieldDeclaration				{if(DEBUG_MODE) printf("<<<<<<<<<<Interface Field Declaration>>>>>>>,line %d\n",yylineno);}
	|
	AbstractMethodDeclaration			{if(DEBUG_MODE) printf("<<<<<<<<<<Interface Method Declaration>>>>>>>,line %d\n",yylineno);}
	|
	//ClassDeclaration   				{if(DEBUG_MODE) printf("<<<<<<<<<<Interface Class Declaration>>>>>>>,line %d\n",yylineno);}
	//|
	//InterfaceDeclaration				{if(DEBUG_MODE) printf("<<<<<<<<<<Interface Interface Declaration>>>>>>>,line %d\n",yylineno);}
	//|	
	SEMICOLON
;
AbstractMethodDeclaration:
	Modifiers Type MethodDeclarator
	{
		m = (struct methodConstructor *)malloc(sizeof(methodConstructor));
		strcpy(m->name,id);
                m->modifier=listOfModifiers;
		listOfModifiers.clear();
                if($2->token==1)
                        m->type=$2->type;
                else
                        strcpy(m->ref,$2->ref);
		m->param=param;
		param.clear();
		listOfClasses[currenterpointer].listOfMethods.push_back(m);
	}
	|
	Type MethodDeclarator 
	{
		m = (struct methodConstructor *)malloc(sizeof(methodConstructor));
		strcpy(m->name,id);
                m->modifier.push_back(mnative);
		listOfModifiers.clear();
                if($1->token==1)
                        m->type=$1->type;
                else
                        strcpy(m->ref,$1->ref);
		m->param=param;
		param.clear();
		listOfClasses[currenterpointer].listOfMethods.push_back(m);
	}
	|
	Modifiers VOID MethodDeclarator 
	{
		m = (struct methodConstructor *)malloc(sizeof(methodConstructor));
		strcpy(m->name,id);
		m->modifier=listOfModifiers;
		listOfModifiers.clear();
		m->type=tvoid;
		m->param=param;
		param.clear();
		listOfClasses[currenterpointer].listOfMethods.push_back(m);
	}
	|
	VOID MethodDeclarator
	{
		m = (struct methodConstructor *)malloc(sizeof(methodConstructor));
		strcpy(m->name,id);
		m->modifier.push_back(mnative);
		m->type=tvoid;
		m->param=param;
		param.clear();
		listOfClasses[currenterpointer].listOfMethods.push_back(m);
	}
;

Block:
	LCBRACE RCBRACE
	|
        LCBRACE BlockStatements RCBRACE
	|
	LCBRACE error RCBRACE
;

BlockStatements:
      BlockStatement
      |
      BlockStatements BlockStatement
;

BlockStatement:
        FieldDeclaration
        |
        ClassDeclaration
	|
	Statement
;
Statement:
	{if(!forSt) createtable(currenter);} Block {if(!forSt) removetable(currenter);}
	|
	SEMICOLON
	|
	StatementExpression SEMICOLON
	|
	Identifier COLON
	{
		fprintf(fcg,"%s:\n",$1);
	}Statement
	|
	IF LRBRACE Expression RRBRACE 
	{
		if($3->type!=tboolean)
			printf("ERROR:erroneous type used in if statement at line %d\n",yylineno);
		else
		{
			char *val=Address($3->contains);
			enum refType t=Ref(val);
			if(t==constant)
				fprintf(fcg,"\nli $t0,%s\n",val);
			else
				fprintf(fcg,"lw $t0,%s\n",val);
			labels.push(num_label++);
			fprintf(fcg,"beqz $t0,L%d\n",labels.top());
		}
	}Statement Other				
	|
	IF error SEMICOLON					{printf("ERROR:Missing ( on line %d\n",yylineno);}
	|
	SWITCH LRBRACE Expression RRBRACE 
	{
		//strcpy(oldswitch,newswitch);
		//strcpy(newswitch,$3->contains);
		switches.push($3->contains);
		labels.push(num_label++);
		break_allowed++;
		break_label.push(labels.top());
		labels.push(num_label++);
	}
	LCBRACE SwitchBlockStatementGroups RCBRACE
	{
		//if($7->type!=tvoid && $3->type!=$7->type)
		//	printf("ERROR:Type mismatch in switch statement at line %d\n",yylineno);
		if(!labels.empty())
		{
			//printf("%d %d\n",labels.top(),break_label);
			while(!labels.empty() && labels.top()!=break_label.top())
			{
				//printf("%d %d\n",labels.top(),break_label);
				fprintf(fcg,"L%d:\n",labels.top());
				labels.pop();
			}
			if(!labels.empty())
			{
				fprintf(fcg,"L%d:\n",labels.top());
				labels.pop();
			}
		}
		//strcpy(newswitch,oldswitch);
		switches.pop();
		break_label.pop();
		break_allowed--;
	}
	|
	SWITCH error SEMICOLON					{printf("ERROR:Missing ( on line %d\n",yylineno);}
	|
	WHILE LRBRACE{break_allowed++;labels.push(num_label++);continue_label.push(labels.top());fprintf(fcg,"\nL%d:\n",labels.top());}Expression RRBRACE
	{
		if($4->type!=tboolean)
			printf("ERROR:erroneous type used in while statement at line %d\n",yylineno);
		else
		{
			char *val=Address($4->contains);
			enum refType t=Ref(val);
			if(t==constant)
				fprintf(fcg,"li $t0,%s\n",val);
			else
				fprintf(fcg,"lw $t0,%s\n",val);
			labels.push(num_label++);
			fprintf(fcg,"beqz $t0,L%d\n",labels.top());
			break_label.push(labels.top());
		}
	}Statement
	{
		if(!labels.empty())
		{
			int val=labels.top();
			labels.pop();
			if(!labels.empty())
			{
				fprintf(fcg,"b L%d\n",labels.top());
				fprintf(fcg,"L%d:\n\n",val);
				labels.pop();
			}
		}
		break_label.pop();
		continue_label.pop();
		break_allowed--;
	}
	|
	WHILE error SEMICOLON					{printf("ERROR:Missing ( on line %d\n",yylineno);}
	|
	DO 
	{
		break_allowed++;
		labels.push(num_label++);continue_label.push(labels.top());
		fprintf(fcg,"\nL%d:\n",labels.top());
		labels.push(num_label++);break_label.push(labels.top());
	}
	Statement WHILE LRBRACE Expression RRBRACE SEMICOLON
	{
		if($6->type!=tboolean)
			printf("ERROR:erroneous type used in if statement at line %d\n",yylineno);
		else
		{
			char *val=Address($6->contains);
			enum refType t=Ref(val);
			if(t==constant)
				fprintf(fcg,"li $t0,%s\n",val);
			else
				fprintf(fcg,"lw $t0,%s\n",val);
			if(!labels.empty())
			{
				int loop=labels.top();
				labels.pop();
				if(!labels.empty())
				{
					fprintf(fcg,"bnez $t0,L%d\n",labels.top());
					fprintf(fcg,"L%d:\n\n",loop);
					labels.pop();
				}
			}
		}
		break_label.pop();
		continue_label.pop();
		break_allowed--;
	}
	|
	DO error SEMICOLON					{printf("ERROR:Missing ( on line %d\n",yylineno);}
	|
	FOR 
	{	createtable(currenter);
		forSt++;
		break_allowed++;
		labels.push(num_label++);//start of statement
		labels.push(num_label++);//end of statement
		break_label.push(labels.top());
		labels.push(num_label++);//expression
		labels.push(num_label++);//update
		continue_label.push(labels.top());
	} 
	LRBRACE ForControl RRBRACE 
	{
		int val1=labels.top();
		labels.pop();
		int val2=labels.top();
		labels.pop();
		fprintf(fcg,"L%d:\n",labels.top());
		labels.pop();
		labels.push(val2);
		labels.push(val1);
	}Statement 
	{	removetable(currenter);
		forSt--;
		if(!labels.empty())
		{
			fprintf(fcg,"b L%d\n",labels.top());
			labels.pop();
			if(!labels.empty())
			{
				fprintf(fcg,"L%d:\n",labels.top());
				labels.pop();
			}
		}
	}
	|
	FOR error SEMICOLON					{printf("ERROR:Missing ( on line %d\n",yylineno);}
	|
	BREAK Identifier SEMICOLON
	|
	BREAK Identifier error SEMICOLON			{printf("ERROR:Missing ; on line %d\n",yylineno);}
	|
	BREAK SEMICOLON
	{
		if(break_allowed)
			fprintf(fcg,"b L%d\n",break_label.top());
		else
			printf("ERROR:illegal use of break at line %d\n",yylineno);
	}
	|
	BREAK error SEMICOLON					{printf("ERROR:Missing ; on line %d\n",yylineno);}
	|
	CONTINUE Identifier SEMICOLON
	{
		if(break_allowed)
			fprintf(fcg,"b %s\n",$2);
		else
			printf("ERROR:illegal use of continue at line %d\n",yylineno);
	}
	|
	CONTINUE Identifier error SEMICOLON			{printf("ERROR:Missing ; on line %d\n",yylineno);}
	|
	CONTINUE SEMICOLON
	{
		if(break_allowed)
			fprintf(fcg,"b L%d\n",continue_label.top());
		else
			printf("ERROR:illegal use of continue at line %d\n",yylineno);
	}
	|
	CONTINUE error SEMICOLON				{printf("ERROR:Missing ; on line %d\n",yylineno);}
	|
	RETURN Expression SEMICOLON
	{
		if($2->token!=returninfo->token)
			printf("ERROR:Invalid return expression at line %d\n",yylineno);
		else if($2->dimension!=returninfo->dimension)
			printf("ERROR:Invalid return expression at line %d\n",yylineno);
		else if($2->token==1 || $2->token==3)
		{
			if(returninfo->type==tdouble && ($2->type==tstring || $2->type==tnull || $2->type==tboolean || \
			$2->type==tnone || $2->type==tvoid))
                		printf("ERROR:Invalid return type on line %d\n",yylineno);
			else if(returninfo->type==tfloat && ($2->type==tdouble || $2->type==tstring || $2->type==tnull || $2->type==tboolean || \
				$2->type==tnone || $2->type==tvoid))
                		printf("ERROR:Invalid return type on line %d\n",yylineno);
			else if(returninfo->type==tlong && !($2->type==tlong || $2->type==tint || $2->type==tbyte || $2->type==tshort || $2->type==tchar))
              			 printf("ERROR:Invalid return type on line %d\n",yylineno);
                	else if(returninfo->type==tint && !($2->type==tint || $2->type==tbyte || $2->type==tshort || $2->type==tchar))
                		 printf("ERROR:Invalid return type on line %d\n",yylineno);
                	else if(returninfo->type==tshort && !($2->type==tbyte || $2->type==tshort || $2->type==tchar))
                		 printf("ERROR:Invalid return type on line %d\n",yylineno);
                	else if(returninfo->type==tbyte && !($2->type==tbyte || $2->type==tchar))
                		 printf("ERROR:Invalid return type on line %d\n",yylineno);
                	else if(returninfo->type==tchar && $2->type!=tchar)
                		 printf("ERROR:Invalid return type on line %d\n",yylineno);
			else if(returninfo->type==tvoid)
				printf("ERROR:return statement used inside a void at line %d\n",yylineno);
			else
			{
				returnFound=true;
				char *val=Address($2->contains);
				if(Ref(val)==constant)
				{
					if(returninfo->type==tdouble || returninfo->type==tdouble)
					{
						if($2->type==tdouble || $2->type==tfloat)
							fprintf(fcg,"li.s $f0,%s\n",val);
						else
						{
							fprintf(fcg,"li $t0,%s\n",val);
							fprintf(fcg,"mtc1 $t0,$f0\n");
							fprintf(fcg,"cvt.s.w $f0,$f0\n");
						}
					}
					else
						fprintf(fcg,"li $v0,%s\n",val);
				}
				else if(Ref(val)==memory)
				{
					if(returninfo->type==tdouble || returninfo->type==tdouble)
					{
						if($2->type==tdouble || $2->type==tfloat)
							fprintf(fcg,"l.s $f0,%s\n",val);
						else
						{
							fprintf(fcg,"lw $t0,%s\n",val);
							fprintf(fcg,"mtc1 $t0,$f0\n");
							fprintf(fcg,"cvt.s.w $f0,$f0\n");
						}
					}
					else if(returninfo->type!=tchar)
						fprintf(fcg,"lw $v0,%s\n",val);
					else
						fprintf(fcg,"lb $v0,%s\n",val);
				}
				else
				{
					if(returninfo->type==tdouble || returninfo->type==tdouble)
					{
						if($2->type==tdouble || $2->type==tfloat)
							fprintf(fcg,"mov.s $f0,%s\n",val);
						else
						{
							fprintf(fcg,"move $t0,%s\n",val);
							fprintf(fcg,"mtc1 $t0,$f0\n");
							fprintf(fcg,"cvt.s.w $f0,$f0\n");
						}
					}
					else
						fprintf(fcg,"move $v0,%s\n",val);
				}
				if(strcmp(m->name,"main"))
					fprintf(fcg,"b %s%dend\n",m->name,method_count-1);
				else
					fprintf(fcg,"b mainend\n");
			}
		}
		else if($2->token==2 || $2->token==4)
		{
			if(strcmp(returninfo->ref,$2->ref))
				printf("ERROR:Invalid return expression at line %d\n",yylineno);
			else
			{
				returnFound=true;
				char *val=Address($2->contains);
				if(Ref(val)==memory)
					fprintf(fcg,"lw $v0,%s\n",val);
				else
					fprintf(fcg,"move $v0,%s\n",val);
				if(strcmp(m->name,"main"))
					fprintf(fcg,"b %s%dend\n",m->name,method_count-1);
				else
					fprintf(fcg,"b mainend\n");
			}
		}
	}
	|
	RETURN SEMICOLON
	{
		if(returninfo->type!=tvoid)
			printf("ERROR:Empty return statement in line %d\n",yylineno);
		else
		{
			if(strcmp(m->name,"main"))
				fprintf(fcg,"b %s%dend\n",m->name,method_count-1);
			else
				fprintf(fcg,"b mainend\n");
		}
	}
	|
	RETURN error RCBRACE					{printf("ERROR:Missing ; on line %d\n",yylineno);}
;
Other:
	{fprintf(fcg,"\nL%d:\n",labels.top());labels.pop();}
	|
	ELSE
	{	
		if(!labels.empty())
		{
			int val=labels.top();
			labels.pop();
			labels.push(num_label++);
			fprintf(fcg,"b L%d\n",labels.top());
			fprintf(fcg,"\nL%d:\n",val);
		}
	}Statement{fprintf(fcg,"\nL%d:\n",labels.top());labels.pop();}
	
StatementExpression:
	Assignment	{$$=(struct attribute *)malloc(sizeof(struct attribute));$$->type=tvoid;}
	|
	PreFixOp	{$$=$1;}	
	|
	PostFixOp	{$$=$1;}
	|	
	MethodInvocation{$$=$1;}
	|
	ClassInstanceCreationExpression{$$=$1;}
;

SwitchBlockStatementGroups:
        SwitchBlockStatementGroup	{$$=$1;}
        |
        SwitchBlockStatementGroups SwitchBlockStatementGroup
	{	$$=(struct attribute *)malloc(sizeof(struct attribute));
		//if(!(($1->type!=tvoid && $2->type==tvoid) || $1->type==$2->type))
		//{
		//	$$->type=tnone;
		//	printf("ERROR:Error in switch statement at line %d\n",yylineno);
		//}
		//else
			$$=$1;
	}			
;

SwitchBlockStatementGroup:
	SwitchLabels 
	{
		if($1->type!=tvoid)
		{
			labels.push(num_label++);
			fprintf(fcg,"b L%d\n",labels.top());
			int val=labels.top();
			labels.pop();
			if(!labels.empty())
			{
				fprintf(fcg,"L%d:\n",labels.top());
				labels.pop();
			}
			labels.push(val);
		}
		else
		{
			if(!labels.empty())
			{
				fprintf(fcg,"L%d:\n",labels.top());
				labels.pop();
			}
		}
	}
	BlockStatements	
	{	$$=$1;
		if(!labels.empty())
		{
			if($1->type!=tvoid)
			{
				int val1=labels.top();
				labels.pop();
				labels.push(num_label++);
				fprintf(fcg,"b L%d\n",labels.top());
				fprintf(fcg,"L%d:\n",val1);
			}
		}
	}
;

SwitchLabels:
        SwitchLabel		{$$=$1;}
        |
        SwitchLabels SwitchLabel
	{	$$=(struct attribute *)malloc(sizeof(struct attribute));
		if(!(($1->type!=tvoid && $2->type==tvoid) || $1->type==$2->type))
		{
			$$->type=tnone;
			printf("ERROR:Error in switch statement at line %d\n",yylineno);
		}
		else
			$$=$1;
	}
;

SwitchLabel:
        CASE Expression COLON	
	{	
		$$=$2;
		if(!labels.empty())
		{
			char *val2=Address($2->contains);
			char *val1=Address(switches.top());
			if($2->type==tfloat || $2->type==tdouble)
			{
				if(Ref(val1)==constant)
					fprintf(fcg,"li.s $f0,%s\n",val1);
				else if(Ref(val1)==memory)
					fprintf(fcg,"l.s $f0,%s\n",val1);
				else
					fprintf(fcg,"mov.s $f0,%s\n",val1);
				if(Ref(val2)==constant)
					fprintf(fcg,"li.s $f1,%s\n",val2);
				else if(Ref(val2)==memory)
					fprintf(fcg,"l.s $f1,%s\n",val2);
				else
					fprintf(fcg,"mov.s $f1,%s\n",val2);
				fprintf(fcg,"c.seq.s $f0,$f1\n");
				fprintf(fcg,"bc1t L%d\n",labels.top());
			}
			else if($2->type==tchar)
			{
				if(Ref(val1)==constant)
					fprintf(fcg,"li $t0,%s\n",val1);
				else if(Ref(val1)==memory)
					fprintf(fcg,"lb $t0,%s\n",val1);
				else
					fprintf(fcg,"move $t0,%s\n",val1);
				if(Ref(val2)==constant)
					fprintf(fcg,"li $t1,%s\n",val2);
				else if(Ref(val2)==memory)
					fprintf(fcg,"lb $t1,%s\n",val2);
				else
					fprintf(fcg,"move $t1,%s\n",val2);
				fprintf(fcg,"seq $t0,$t0,$t1\n");
				fprintf(fcg,"bnez $t0,L%d\n",labels.top());
			}
			else
			{
				if(Ref(val1)==constant)
					fprintf(fcg,"li $t0,%s\n",val1);
				else if(Ref(val1)==memory)
					fprintf(fcg,"lw $t0,%s\n",val1);
				else
					fprintf(fcg,"move $t0,%s\n",val1);
				if(Ref(val2)==constant)
					fprintf(fcg,"li $t1,%s\n",val2);
				else if(Ref(val2)==memory)
					fprintf(fcg,"lw $t1,%s\n",val2);
				else
					fprintf(fcg,"move $t1,%s\n",val2);
				fprintf(fcg,"seq $t0,$t0,$t1\n");
				fprintf(fcg,"bnez $t0,L%d\n",labels.top());
			}
		}
	}
	|
        DEFAULT COLON		
	{	
		$$=(struct attribute *)malloc(sizeof(struct attribute));
		$$->type=tvoid;
		fprintf(fcg,"b L%d\n",labels.top());
	}
	|
	CASE Expression error SEMICOLON	{printf("ERROR:Missing : on line %d\n",yylineno);}
;
ForControl:
	ForInit SEMICOLON NoCheck SEMICOLON
	{
		fprintf(fcg,"L%d:\n",labels.top());
		int val=labels.top();
		labels.pop();
		fprintf(fcg,"b L%d\n",labels.top());
		labels.pop();
		labels.push(val);
	}
	|
	ForInit SEMICOLON Check SEMICOLON
	{
		fprintf(fcg,"L%d:\n",labels.top());
		int val=labels.top();
		labels.pop();
		fprintf(fcg,"b L%d\n",labels.top());
		labels.pop();
		labels.push(val);
	}
	|
	ForInit error SEMICOLON {printf("ERROR:Missing ; on line %d\n",yylineno);}
	|
	ForInit SEMICOLON Check SEMICOLON {fprintf(fcg,"L%d:\n",labels.top());}ForUpdate
	{
		int val=labels.top();
		labels.pop();
		fprintf(fcg,"b L%d\n",labels.top());
		labels.pop();
		labels.push(val);
	}
	|
	ForInit SEMICOLON NoCheck SEMICOLON {fprintf(fcg,"L%d:\n",labels.top());}ForUpdate
	{
		int val=labels.top();
		labels.pop();
		fprintf(fcg,"b L%d\n",labels.top());
		labels.pop();
		labels.push(val);
	}
;
Check:
	{
		int val=labels.top();
		labels.pop();
		fprintf(fcg,"L%d:\n",labels.top());
		labels.push(val);
	}
	Expression
	{
		if($2->type!=tboolean)
			printf("ERROR:Type mismatch in for statement at line %d\n",yylineno);
		char *val=Address($2->contains);
		if(Ref(val)==memory)
			fprintf(fcg,"lw $t0,%s\n",val);
		else if(Ref(val)==reg)
			fprintf(fcg,"move $t0,%s\n",val);
		else
			fprintf(fcg,"li $t0,%s\n",val);
		int val1=labels.top();
		labels.pop();
		int val2=labels.top();
		labels.pop();
		int val3=labels.top();
		labels.pop();
		int val4=labels.top();
		labels.pop();
		fprintf(fcg,"bnez $t0,L%d\n",val4);
		fprintf(fcg,"b L%d\n",val3);
		labels.push(val4);
		labels.push(val3);
		labels.push(val2);
		labels.push(val1);
	}
;
NoCheck:
	{
		int val1=labels.top();
		labels.pop();
		int val2=labels.top();
		labels.pop();
		int val3=labels.top();
		labels.pop();
		int val4=labels.top();
		labels.pop();
		fprintf(fcg,"L%d:\n",val2);
		fprintf(fcg,"b L%d\n",val4);
		labels.push(val4);
		labels.push(val3);
		labels.push(val2);
		labels.push(val1);
	}
;
ForInit:
	StatementExpressionList
	|
;

ForUpdate:
        StatementExpressionList
;

StatementExpressionList:
	StatementExpression
        |
        StatementExpressionList COMMA StatementExpression
;
Primary:
	PrimaryNoNewArray	{$$=$1;}
	|
	ArrayCreationExpression {$$=$1;}
;
PrimaryNoNewArray:
	Literal			{$$=$1;}
	|
	THIS			
	{ 	$$=(struct attribute *)malloc(sizeof(struct attribute));
		strcpy($$->ref,listOfClasses[currenterpointer].name);
		$$->token=2;
		$$->dimension=0;
		strcpy($$->contains,"$s7");
		if(find(returninfo->modifier.begin(),returninfo->modifier.end(),mstatic)!=returninfo->modifier.end())
		{
			$$->type=tnone;
			printf("ERROR:illegal usage of this at line %d\n",yylineno);
		}
	}
	|
	LRBRACE Expression RRBRACE	{$$=$2;}
	|
	ClassInstanceCreationExpression	{$$=$1;}
	|
	FieldAccess			{$$=$1;}
	|
	MethodInvocation		{$$=$1;}
	|
	ArrayAccess			{$$=$1;}
;
ClassInstanceCreationExpression:
	NEW TypeName LRBRACE ArgumentList RRBRACE
	{
		struct ClassInterface *t=(struct ClassInterface *)malloc(sizeof(struct ClassInterface));
		bool found=false;
		struct methodConstructor *m=new struct methodConstructor;
		int p=listOfClasses.size()-1;
		while(!found && p>=0)
		{
			t=&listOfClasses[p--];
			if(strcmp(t->name,$2->ref))
				continue;
			for(int j=0;j<t->listOfMethods.size() && !found;j++)
			{
				//printf("%d %d\n",t->listOfMethods[j]->param.size(),param.size());
				if(strcmp(t->listOfMethods[j]->name,t->name)==0 && t->listOfMethods[j]->param.size()==param.size())
				{
					found=compare(t->listOfMethods[j]->param,param);
					m=t->listOfMethods[j];
					if(t!=&listOfClasses[currenterpointer])
					{
						if(find(t->listOfMethods[j]->modifier.begin(),t->listOfMethods[j]->modifier.end(),mprivate)!=t->listOfMethods[j]->modifier.end())
							found=false;
					}
				}
			}
		}
		if(!found)
		{ 
			$$=(struct attribute *)malloc(sizeof(struct attribute));
			$$->type=tnone;
			printf("ERROR:Illegal constructor invocation at line %d\n",yylineno);
		}
		else
		{
			$$=$2;
			char *temp=getNewTemp();
			strcpy($$->contains,temp);
			int off=(temp[2]-'0')*10+temp[3]-'0';
			offset_temp[off]=-num_var*4;
			num_var++;
			int i,nonstatic=1;
			t=&listOfClasses[p+1];
			ST *tab=t->table;
			while(tab!=NULL)
			{
				for(i=0;i<tab->entries.size();i++)
				{
					if(find(tab->entries[i].modifiers.begin(),tab->entries[i].modifiers.end(),mstatic)==tab->entries[i].modifiers.end())
						nonstatic++;
				}
				if(t->extends!=NULL)
				{
					tab=t->extends->table;
					t=t->extends;
				}
				else
					tab=NULL;
			}	
			fprintf(fcg,"li $a0,%d\n",4*nonstatic);
			fprintf(fcg,"li $v0,9\n");
			fprintf(fcg,"syscall\n");
			fprintf(fcg,"move $s7,$v0\n");
			int j,nonfloat=0,fl=12;
			for(j=0;j<param.size();j++)		//currently restrciting to only 4 parameters
			{
				char *val=Address(param[j]->contains);
				if((m->param[j]->type==tfloat || m->param[j]->type==tdouble) && m->param[j]->token==1)
				{
					if(param[j]->type!=tfloat && param[j]->type!=tdouble)
					{
						if(Ref(val)==constant)
							fprintf(fcg,"li $t0,%s\n",val);
						else if(Ref(val)==memory)
							fprintf(fcg,"lw $t0,%s\n",val);
						else
							fprintf(fcg,"move $t0,%s\n",val);
						fprintf(fcg,"mtc1 $t0,$f1\n");
						fprintf(fcg,"cvt.s.w $f1,$f1\n");
						fprintf(fcg,"mov.s $f%d,$f1\n",fl++);
					}
					else
					{
						if(Ref(val)==constant)
							fprintf(fcg,"li.s $f%d,%s\n",fl++,val);
						else if(Ref(val)==memory)
							fprintf(fcg,"l.s $f%d,%s\n",fl++,val);
						else
							fprintf(fcg,"mov.s $f%d,%s\n",fl++,val);
					}	
				}
				else
				{
					if(Ref(val)==constant)
						fprintf(fcg,"li $a%d,%s\n",nonfloat++,val);
					else if(Ref(val)==memory)
						fprintf(fcg,"lw $a%d,%s\n",nonfloat++,val);
					else
						fprintf(fcg,"move $a%d,%s\n",nonfloat++,val);
				}
			}
			fprintf(fcg,"sw $v0,%s\n",offToAddr(offset_temp[off]));
			fprintf(fcg,"\njal %s%d\n",m->name,m->number);
			//fprintf(fcg,"lw $s7,4($sp)\n");
		}
		param.clear();
	}
	|
	NEW TypeName LRBRACE RRBRACE
	{
		$$=(struct attribute *)malloc(sizeof(struct attribute));
		struct ClassInterface *t=(struct ClassInterface *)malloc(sizeof(struct ClassInterface));
		struct methodConstructor *m=new struct methodConstructor;
		bool found=false,alone=true;
		int p=listOfClasses.size()-1;
		while(!found && p>=0)
		{
			t=&listOfClasses[p--];
			if(strcmp(t->name,$2->ref))
			{
				alone=false;
				continue;
			}
			alone=true;
			for(int j=0;j<t->listOfMethods.size() && !found;j++)
			{
				if(strcmp(t->listOfMethods[j]->name,t->name)==0)
				{
					alone=false;
					if(t->listOfMethods[j]->param.size()==0)
					{
						m=t->listOfMethods[j];
						found=true;
						if(t!=&listOfClasses[currenterpointer])
						{
							if(find(t->listOfMethods[j]->modifier.begin(),t->listOfMethods[j]->modifier.end(),mprivate)!=t->listOfMethods[j]->modifier.end())
								found=false;
						}
					}
				}
			}
			break;
		}
		if(alone)
			found=true;
		if(!found)
		{ 	
			$$->type=tnone;
			$$->token=1;
			printf("ERROR:Illegal constructor invocation at line %d\n",yylineno);
		}
		else
		{
			$$=$2;
			char *temp=getNewTemp();
			strcpy($$->contains,temp);
			int off=(temp[2]-'0')*10+temp[3]-'0';
			offset_temp[off]=-num_var*4;
			num_var++;
			int i,nonstatic=1;
			t=&listOfClasses[p+1];
			ST *tab=t->table;
			while(tab!=NULL)
			{
				for(i=0;i<tab->entries.size();i++)
				{
					if(find(tab->entries[i].modifiers.begin(),tab->entries[i].modifiers.end(),mstatic)==tab->entries[i].modifiers.end())
						nonstatic++;
				}
				if(t->extends!=NULL)
				{
					tab=t->extends->table;
					t=t->extends;
				}
				else
					tab=NULL;
			}	
			fprintf(fcg,"li $a0,%d\n",4*nonstatic);
			fprintf(fcg,"li $v0,9\n");
			fprintf(fcg,"syscall\n");
			if(alone)
			{
				nonstatic=1;
				t=&listOfClasses[p+1];
				tab=t->table;
				while(tab!=NULL)
				{
					for(i=0;i<tab->entries.size();i++)
					{
						if(find(tab->entries[i].modifiers.begin(),tab->entries[i].modifiers.end(),mstatic)==tab->entries[i].modifiers.end())
						{
							if(tab->entries[i].btype==tfloat || tab->entries[i].btype==tdouble)
							{
								fprintf(fcg,"li.s $f0,0.0\n");						
								fprintf(fcg,"s.s $f0,%d($v0)\n",4*nonstatic);
							}
							else if(tab->entries[i].btype!=tchar)
							{
								fprintf(fcg,"li $t0,0\n");						
								fprintf(fcg,"sw $t0,%d($v0)\n",4*nonstatic);
							}
							else
							{
								fprintf(fcg,"li $t0,0\n");						
								fprintf(fcg,"sb $t0,%d($v0)\n",4*nonstatic);
							}
							nonstatic++;
						}
					}
					if(t->extends!=NULL)
					{
						tab=t->extends->table;
						t=t->extends;
					}
					else
						tab=NULL;
				}
				fprintf(fcg,"sw $v0,%s\n",offToAddr(offset_temp[off]));
			}
			else
			{
				fprintf(fcg,"sw $s7,4($sp)\n");
				fprintf(fcg,"move $s7,$v0\n");
				fprintf(fcg,"sw $v0,%s\n",offToAddr(offset_temp[off]));
				fprintf(fcg,"jal %s%d\n",m->name,m->number);
				fprintf(fcg,"lw $s7,4($sp)\n");
			}
		}		
	}
	|
        NEW  TypeName LRBRACE  error SEMICOLON { $$=(struct attribute *)malloc(sizeof(struct attribute));$$->type=tnone;printf("ERROR:Missing ) on line %d\n",yylineno);}
	|
        NEW TypeName  LRBRACE ArgumentList error { param.clear();$$=(struct attribute *)malloc(sizeof(struct attribute));$$->type=tnone;printf("ERROR:Missing ) on line %d\n",yylineno);}
;
ArgumentList:
	Expression
	{
		param.clear();
		struct attribute *at=(struct attribute *)malloc(sizeof(struct attribute));
		if($1->token==1 || $1->token==3)
			at->type=$1->type;
		else
			strcpy(at->ref,$1->ref);
		at->modifier=$1->modifier;
		at->token=$1->token;
		at->dimension=$1->dimension;
		strcpy(at->contains,$1->contains);
		param.push_back(at);
	}
	|
	ArgumentList COMMA Expression
	{
		struct attribute *at=(struct attribute *)malloc(sizeof(struct attribute));
		if($3->token==1 || $3->token==3)
			at->type=$3->type;
		else
			strcpy(at->ref,$3->ref);
		at->modifier=$3->modifier;
		at->token=$3->token;
		at->dimension=$3->dimension;
		strcpy(at->contains,$3->contains);
		param.push_back(at);
	}			
;
ArrayCreationExpression:
	NEW Primitive DimExprs Dims
	{ 	$$=(struct attribute *)malloc(sizeof(struct attribute));
		$$->type=$2->type;
		$$->dimension=$3->dimension+$4->dimension;
		$$->token=3;
	}	
	|
	NEW Primitive DimExprs
	{ 	$$=(struct attribute *)malloc(sizeof(struct attribute));
		$$->type=$2->type;
		$$->dimension=$3->dimension;
		$$->token=3;
		char *val=Address($3->contains);
		
		char *temp=getNewTemp();

		int i;
		for(i=0;i<strlen(temp);i++)
			$$->contains[i]=temp[i];
		$$->contains[i]='\0';

		int off=(temp[2]-'0')*10+temp[3]-'0';
		offset_temp[off]=-num_var*4;
		num_var++;
		
		if(Ref(val)==memory)
			fprintf(fcg,"lw $t0,%s\n",val);
		else if(Ref(val)==reg)
			fprintf(fcg,"move $t0,%s\n",val);
		else
			fprintf(fcg,"li $t0,%s\n",val);
		fprintf(fcg,"add $t0,$t0,1\n");
		fprintf(fcg,"mul $t0,$t0,4\n");
		fprintf(fcg,"move $a0,$t0\n");
		fprintf(fcg,"li $v0,9\n");
		fprintf(fcg,"syscall\n");
		fprintf(fcg,"sw $v0,%s\n",Address(temp));
		jump_found=true;
	}		
	|
	NEW ClassOrInterfaceType DimExprs Dims
	{ 	$$=(struct attribute *)malloc(sizeof(struct attribute));
		strcpy($$->ref,$2->ref);
		$$->dimension=$3->dimension+$4->dimension;
		$$->token=4;
	}	
	|
	NEW ClassOrInterfaceType DimExprs
	{ 	$$=(struct attribute *)malloc(sizeof(struct attribute));
		strcpy($$->ref,$2->ref);
		$$->dimension=$3->dimension;
		$$->token=4;

		char *temp=getNewTemp();
		strcpy($$->contains,temp);
		int off=(temp[2]-'0')*10+temp[3]-'0';
		offset_temp[off]=-num_var*4;
		num_var++;
		char *val=Address($3->contains);
		
		if(Ref(val)==memory)
			fprintf(fcg,"lw $t0,%s\n",val);
		else if(Ref(val)==reg)
			fprintf(fcg,"move $t0,%s\n",val);
		else
			fprintf(fcg,"li $t0,%s\n",val);
		fprintf(fcg,"addu $t0,$t0,1\n");
		fprintf(fcg,"mul $t0,$t0,%d\n",4);
		fprintf(fcg,"move $a0,$t0\n");
		fprintf(fcg,"li $v0,9\n");
		fprintf(fcg,"syscall\n");
		fprintf(fcg,"sw $v0,%s\n",Address(temp));
		jump_found=true;
	}	
;
DimExprs:
	DimExpr			{ $$=(struct attribute *)malloc(sizeof(struct attribute));$$->dimension=1;strcpy($$->contains,$1->contains);}
	|
	DimExprs DimExpr	{ $$=(struct attribute *)malloc(sizeof(struct attribute));$$->dimension=$1->dimension+1;}
;
DimExpr:
	LSBRACE Expression RSBRACE {$$=$2;}
;
Dims:
	LSBRACE RSBRACE		{ $$=(struct attribute *)malloc(sizeof(struct attribute));$$->dimension=1;}
	|
	Dims LSBRACE RSBRACE	{ $$=(struct attribute *)malloc(sizeof(struct attribute));$$->dimension=$1->dimension+1;}
;
FieldAccess:
	Identifier DOT Identifier
	{ 	
		$$=(struct attribute *)malloc(sizeof(struct attribute));
		struct ClassInterface *t2=(struct ClassInterface *)malloc(sizeof(struct ClassInterface));
		bool found=false,stat=false,off=0;
		char name[1024];
		ST *tab=currenter;
		STE *t1=(STE *)malloc(sizeof(STE));
		int loc=0;
		for(;loc<listOfClasses.size();loc++)
		{
			if(strcmp(listOfClasses[loc].name,$1)==0)
				break;
		}
		if(loc!=listOfClasses.size())
		{
			t1=findentry(listOfClasses[loc].table,$3);
			if(t1!=NULL)
			{
				for(loc=0;loc<t1->modifiers.size();loc++)
				{
					if(t1->modifiers[loc]==mstatic)
						break;
				}
				if(loc!=t1->modifiers.size())
				{
					stat=true;
					found=true;
					$$->dimension=t1->dimension;
					$$->token=$$->dimension>0?3:1;
					$$->type=t1->btype;	
					strcpy($$->contains,offToAddr(t1->offset));
				}
			}
		}
		else
		{
			while(tab!=NULL && !found)
			{
				t1=findentry(tab,$1);
				if(t1!=NULL)
					found=true;
				else
					tab=tab->prev;
			}
			if(!found)
				printf("ERROR:Illegal field access at line %d\n",yylineno);
			else
			{
				strcpy(name,t1->ref);
				int loc=0;
				for(;loc<listOfClasses.size();loc++)
				{
					if(strcmp(listOfClasses[loc].name,name)==0)
						break;
				}
				t2=&listOfClasses[loc];
				found=false;
				while(t2!=NULL && !found)
				{
					t1=findentry(t2->table,$3);
					if(!t1)
						t2=t2->extends;
					else
					{
						found=true;
						if(t2!=&listOfClasses[currenterpointer])
						{
							if(find(t1->modifiers.begin(),t1->modifiers.end(),mprivate)!=t1->modifiers.end())
							{t2=t2->extends;found=false;}	
						}
					}
				}
		        	if(!found)
					printf("ERROR:No variable of name %s found\n",$3);
				else
				{
					$$->dimension=t1->dimension;
					if(t1->btype==tnone)
					{
						$$->token=$$->dimension>0?4:2;
						strcpy($$->ref,t1->ref);
					}
					else
					{
						$$->token=$$->dimension>0?3:1;
						$$->type=t1->btype;
					}
					char *val=Address($1);
					fprintf(fcg,"lw $t0,%s\n",val);
					int nonstatic=1,i=0,total=1,barrier=0;
					found=false;
					t2=&listOfClasses[loc];
					tab=t2->table;
					while(tab!=NULL)
					{
						for(i=0;i<tab->entries.size();i++)
						{
							if(find(tab->entries[i].modifiers.begin(),tab->entries[i].modifiers.end(),mstatic)==tab->entries[i].modifiers.end())
								total++;
						}
						if(t2->extends!=NULL)
						{
							tab=t2->extends->table;
							t2=t2->extends;
						}
						else
							tab=NULL;
					}
					t2=&listOfClasses[loc];
					tab=t2->table;
					while(tab!=NULL && !found)
					{
						nonstatic=0;
						for(i=0;i<tab->entries.size();i++)
						{
							if(find(tab->entries[i].modifiers.begin(),tab->entries[i].modifiers.end(),mstatic)==tab->entries[i].modifiers.end())
							{
								if(!strcmp(tab->entries[i].lexeme,$3))
								{
									found=true;
									break;
								}
								nonstatic++;
							}
						}
						barrier+=tab->entries.size();
						if(!found)
						{
							if(t2->extends!=NULL)
							{
								tab=t2->extends->table;
								t2=t2->extends;
							}
							else
								tab=NULL;
						}
					}
					if(!found)
						printf("ERROR:cannot access a static member from an object\n");
					else
					{
						fprintf(fcg,"addu $t0,$t0,%d\n",4*(nonstatic+total-barrier));
						fprintf(fcg,"move $t%d,$t0\n",next_loc_reg);
						fprintf(fcg,"\n");
						char temp[64];
						temp[0]='0';
						temp[1]='(';
						temp[2]='$';
						temp[3]='t';
						temp[4]='0'+next_loc_reg;
						temp[5]=')';
						temp[6]='\0';
						strcpy($$->contains,temp);
						next_loc_reg=(next_loc_reg+1)%10>=3?(next_loc_reg+1)%10:3;
					}
				}
			}
		}
	}
	|
	Primary DOT Identifier
	{ 	
		$$=(struct attribute *)malloc(sizeof(struct attribute));
		if($1->token!=2)
		{
			$$->type=tnone;
			printf("ERROR:Illegal field invocation at line %d\n",yylineno);
		}
		else
		{
			struct ClassInterface *t2=(struct ClassInterface *)malloc(sizeof(struct ClassInterface));
			int p=currenterpointer;
			while(p>=0)
			{	
				t2=&listOfClasses[p];
				if($1->ref!=NULL && !strcmp(t2->name,$1->ref))
					break;
				else
					p--;
			}
			bool found=false;
			STE *t1=NULL;
			found=false;
			while(t2!=NULL && !found)
			{
				t1=findentry(t2->table,$3);
				if(!t1)
					t2=t2->extends;
				else
				{
					found=true;
					if(t2!=&listOfClasses[currenterpointer])
					{
						if(find(t1->modifiers.begin(),t1->modifiers.end(),mprivate)!=t1->modifiers.end())
						{t2=t2->extends;found=false;}	
					}
				}
			}
			if(t1)
				found=true;
			if(!found)
			{
				$$->type=tnone;
				printf("ERROR:No variable of name %s found\n",$3);
			}
			else
			{
				$$->dimension=t1->dimension;
				if(t1->btype==tnone)
				{
					$$->token=$$->dimension>0?4:2;
					strcpy($$->ref,t1->ref);
				}
				else
				{
					$$->token=$$->dimension>0?3:1;
					$$->type=t1->btype;
				}
				char *val=Address($1->contains);
				if(Ref(val)==memory)
					fprintf(fcg,"lw $t0,%s\n",val);
				else
					fprintf(fcg,"move $t0,%s\n",val);
				found=false;
				int nonstatic=0,i=0,barrier=0,total=1;
				t2=&listOfClasses[p];
				ST *tab=t2->table;
				while(tab!=NULL)
				{
					for(i=0;i<tab->entries.size();i++)
					{
						if(find(tab->entries[i].modifiers.begin(),tab->entries[i].modifiers.end(),mstatic)==tab->entries[i].modifiers.end())
							total++;
					}
					if(t2->extends!=NULL)
					{
						tab=t2->extends->table;
						t2=t2->extends;
					}
						else
							tab=NULL;
				}
				t2=&listOfClasses[p];
				tab=t2->table;
				while(tab!=NULL && !found)
				{
					nonstatic=0;
					for(i=0;i<tab->entries.size();i++)
					{
						if(find(tab->entries[i].modifiers.begin(),tab->entries[i].modifiers.end(),mstatic)==tab->entries[i].modifiers.end())
						{
							if(!strcmp(tab->entries[i].lexeme,$3))
							{
								found=true;
								break;
							}
							nonstatic++;
						}
					}
					barrier+=tab->entries.size();
					if(!found)
					{
						if(t2->extends!=NULL)
						{
							tab=t2->extends->table;
							t2=t2->extends;
						}
						else
							tab=NULL;
					}
				}
				if(!found)
					printf("ERROR:cannot access static member using an object\n");
				else
				{
						fprintf(fcg,"addu $t0,$t0,%d\n",4*(nonstatic+total-barrier));
						fprintf(fcg,"move $t%d,$t0\n",next_loc_reg);
						fprintf(fcg,"\n");
						char temp[64];
						temp[0]='0';
						temp[1]='(';
						temp[2]='$';
						temp[3]='t';
						temp[4]='0'+next_loc_reg;
						temp[5]=')';
						temp[6]='\0';
						strcpy($$->contains,temp);
						next_loc_reg=(next_loc_reg+1)%10>=3?(next_loc_reg+1)%10:3;
				}
			}
		}
	}
	|	
	SUPER DOT Identifier
	{ 	$$=(struct attribute *)malloc(sizeof(struct attribute));
		struct ClassInterface *t2=(struct ClassInterface *)malloc(sizeof(struct ClassInterface));	
		t2=listOfClasses[currenterpointer].extends;
		bool found=false;
		STE *t1;
		if(t2!=NULL)
		{
			t1=findentry(t2->table,$3);
			if(t1)
				found=true;
		}
		if(!found)
			printf("ERROR:No variable of name %s found\n",$3);
		else
		{
			$$->dimension=t1->dimension;
			if(t1->btype==tnone)
			{
				$$->token=$$->dimension>0?4:2;
				strcpy($$->ref,t1->ref);
			}
			else
			{
				$$->token=$$->dimension>0?3:1;
				$$->type=t1->btype;
			}
		}
	}
;
MethodInvocation:
	PRINTL LRBRACE Expression RRBRACE		
	{ 	
		$$=(struct attribute *)malloc(sizeof(struct attribute));$$->type=tvoid;$$->token=1;$$->dimension=0;
		char *val=Address($3->contains);
		if(Ref(val)==constant)
		{
			if($3->token==1)
			{
				if($3->type==tdouble || $3->type==tfloat)
				{
					fprintf(fcg,"li.s $f12,%s\n",val);
					fprintf(fcg,"li $v0,2\n");
				}
				else if($3->type!=tchar)
				{
					fprintf(fcg,"li $a0,%s\n",val);
					fprintf(fcg,"li $v0,1\n");
				}
				else
				{
					fprintf(fcg,"li $a0,%s\n",val);
					fprintf(fcg,"li $v0,11\n");
				}
				fprintf(fcg,"syscall\n");
				fprintf(fcg,"la $a0,newline\n");
				fprintf(fcg,"li $v0,4\n");
				fprintf(fcg,"syscall\n");
			}
			else
			{
				fprintf(fcg,".data\n");
				fprintf(fcg,"__print%d:\t.asciiz \%s\n",num_print++,val);
				fprintf(fcg,".text\n");
				fprintf(fcg,"la $a0,__print%d\n",num_print-1);
				fprintf(fcg,"li $v0,4\n");
				fprintf(fcg,"syscall\n\n");
				fprintf(fcg,"la $a0,newline\n");
				fprintf(fcg,"li $v0,4\n");
				fprintf(fcg,"syscall\n");
				
			}	
		}
		else if(Ref(val)==memory)
		{
			if($3->type==tdouble || $3->type==tfloat)
			{
				fprintf(fcg,"l.s $f12,%s\n",val);
				fprintf(fcg,"li $v0,2\n");
			}
			else if($3->type!=tchar)
			{
				fprintf(fcg,"lw $a0,%s\n",val);
				fprintf(fcg,"li $v0,1\n");
			}
			else
			{
				fprintf(fcg,"lb $a0,%s\n",val);
				fprintf(fcg,"li $v0,11\n");
			}
			fprintf(fcg,"syscall\n");
			fprintf(fcg,"la $a0,newline\n");
			fprintf(fcg,"li $v0,4\n");
			fprintf(fcg,"syscall\n");
		}
		else
		{
			if($3->type==tdouble || $3->type==tfloat)
			{
				fprintf(fcg,"mov.s $f12,%s\n",val);
				fprintf(fcg,"li $v0,2\n");
			}
			else if($3->type!=tchar)
			{
				fprintf(fcg,"move $a0,%s\n",val);
				fprintf(fcg,"li $v0,1\n");
			}
			else
			{
				fprintf(fcg,"move $a0,%s\n",val);
				fprintf(fcg,"li $v0,11\n");
			}
			fprintf(fcg,"syscall\n");
			fprintf(fcg,"la $a0,newline\n");
			fprintf(fcg,"li $v0,4\n");
			fprintf(fcg,"syscall\n");
		}
	}
	|
	PRINTL LRBRACE Expression error SEMICOLON	{ $$=(struct attribute *)malloc(sizeof(struct attribute));$$->type=tnone;printf("ERROR:Missing ) on line %d\n",yylineno);}
	|
	PRINTL error SEMICOLON 				{ $$=(struct attribute *)malloc(sizeof(struct attribute));$$->type=tnone;printf("ERROR:Missing ( on line %d\n",yylineno);}
	|
	PRINT LRBRACE Expression RRBRACE		
	{ 
		$$=(struct attribute *)malloc(sizeof(struct attribute));
		$$->type=tvoid;$$->token=1;
		$$->dimension=0;
		char *val=Address($3->contains);
		if(Ref(val)==constant)
		{
			if($3->token==1)
			{
				if($3->type==tdouble || $3->type==tfloat)
				{
					fprintf(fcg,"li.s $f12,%s\n",val);
					fprintf(fcg,"li $v0,2\n");
					fprintf(fcg,"syscall\n");
				}
				else if($3->type!=tchar)
				{
					fprintf(fcg,"li $a0,%s\n",val);
					fprintf(fcg,"li $v0,1\n");
					fprintf(fcg,"syscall\n");
				}
				else
				{
					fprintf(fcg,"li $a0,%s\n",val);
					fprintf(fcg,"li $v0,11\n");
					fprintf(fcg,"syscall\n");
				}
			}
			else
			{
				fprintf(fcg,".data\n");
				fprintf(fcg,"__print%d:\t.asciiz %s\n",num_print++,val);
				fprintf(fcg,".text\n");
				fprintf(fcg,"la $a0,__print%d\n",num_print-1);
				fprintf(fcg,"li $v0,4\n");
				fprintf(fcg,"syscall\n\n");
			}	
		}
		else if(Ref(val)==memory)
		{
			if($3->type==tdouble || $3->type==tfloat)
			{
				fprintf(fcg,"l.s $f12,%s\n",val);
				fprintf(fcg,"li $v0,2\n");
				fprintf(fcg,"syscall\n");
			}
			else if($3->type!=tchar)
			{
				fprintf(fcg,"lw $a0,%s\n",val);
				fprintf(fcg,"li $v0,1\n");
				fprintf(fcg,"syscall\n");
			}
			else
			{
				fprintf(fcg,"lb $a0,%s\n",val);
				fprintf(fcg,"li $v0,11\n");
				fprintf(fcg,"syscall\n");
			}
		}
		else
		{
			if($3->type==tdouble || $3->type==tfloat)
			{
				fprintf(fcg,"mov.s $f12,%s\n",val);
				fprintf(fcg,"li $v0,2\n");
				fprintf(fcg,"syscall\n");
			}
			else if($3->type!=tchar)
			{
				fprintf(fcg,"move $a0,%s\n",val);
				fprintf(fcg,"li $v0,1\n");
				fprintf(fcg,"syscall\n");
			}
			else
			{
				fprintf(fcg,"move $a0,%s\n",val);
				fprintf(fcg,"li $v0,11\n");
				fprintf(fcg,"syscall\n");
			}
		}
	}
	|
	PRINT LRBRACE Expression error SEMICOLON	{ $$=(struct attribute *)malloc(sizeof(struct attribute));$$->type=tnone;printf("ERROR:Missing ) on line %d\n",yylineno);}
	|
	PRINT error SEMICOLON 				{ $$=(struct attribute *)malloc(sizeof(struct attribute));$$->type=tnone;printf("ERROR:Missing ( on line %d\n",yylineno);}
	|
	PRINT LRBRACE RRBRACE				{ $$=(struct attribute *)malloc(sizeof(struct attribute));$$->type=tvoid;$$->token=1;$$->dimension=0;}
	|
	PRINT LRBRACE error SEMICOLON			{ $$=(struct attribute *)malloc(sizeof(struct attribute));$$->type=tnone;printf("ERROR:Missing ) on line %d\n",yylineno);}
	|
	PRINTL LRBRACE RRBRACE				
	{ 	$$=(struct attribute *)malloc(sizeof(struct attribute));
		$$->type=tvoid;$$->token=1;
		$$->dimension=0;
		fprintf(fcg,"la $a0,newline\n");
		fprintf(fcg,"li $v0,4\n");
		fprintf(fcg,"syscall\n");
	}
	|
	PRINTL LRBRACE error SEMICOLON			{ $$=(struct attribute *)malloc(sizeof(struct attribute));$$->type=tnone;printf("ERROR:Missing ) on line %d\n",yylineno);}
	|
	Identifier LRBRACE ArgumentList RRBRACE
	{
		$$=(struct attribute *)malloc(sizeof(struct attribute));
		struct ClassInterface *t=&listOfClasses[currenterpointer];
		bool found=false;
		int j;
		enum Basic tp=tvoid;
		char typ[1024];
		int tk=1;
		struct methodConstructor *m;
		while(t!=NULL && !found)
		{
			for(j=0;j<t->listOfMethods.size() && !found;j++)
			{
				if(strcmp(t->listOfMethods[j]->name,$1)==0 && t->listOfMethods[j]->param.size()==param.size())
				{
					m=t->listOfMethods[j];
					if(t->listOfMethods[j]->token==1)
						tp=t->listOfMethods[j]->type;
					else
					{
						tk=0;
						strcpy(typ,t->listOfMethods[j]->ref);
					}
					$$->dimension=0;
					found=compare(t->listOfMethods[j]->param,param);
					if(find(returninfo->modifier.begin(),returninfo->modifier.end(),mstatic)!=returninfo->modifier.end())
					{
						if(find(t->listOfMethods[j]->modifier.begin(),t->listOfMethods[j]->modifier.end(),mstatic)==t->listOfMethods[j]->modifier.end())
							found=false;
					}
					if(t!=&listOfClasses[currenterpointer])
					{
						if(find(t->listOfMethods[j]->modifier.begin(),t->listOfMethods[j]->modifier.end(),mprivate)!=t->listOfMethods[j]->modifier.end())
							found=false;
					}						
				}
			}
			t=t->extends;	
		}
		if(!found)
		{
			$$->type=tnone;
			printf("ERROR:Illegal method invocation at line %d\n",yylineno);
		}
		else
		{
			if(tk)
			{
				$$->token=1;	
				$$->type=tp;
			}
			else
			{
				strcpy($$->ref,typ);
				$$->token=2;
			}
		
				int nonfloat=0,fl=12;
				for(j=0;j<param.size();j++)		//currently restrciting to only 4 parameters
				{
					char *val=Address(param[j]->contains);
					if((m->param[j]->type==tfloat || m->param[j]->type==tdouble) && m->param[j]->token==1)
					{
						if(param[j]->type!=tfloat && param[j]->type!=tdouble)
						{
							if(Ref(val)==constant)
								fprintf(fcg,"li $t0,%s\n",val);
							else if(Ref(val)==memory)
								fprintf(fcg,"lw $t0,%s\n",val);
							else
								fprintf(fcg,"move $t0,%s\n",val);
							fprintf(fcg,"mtc1 $t0,$f1\n");
							fprintf(fcg,"cvt.s.w $f1,$f1\n");
							fprintf(fcg,"mov.s $f%d,$f1\n",fl++);
						}
						else
						{
							if(Ref(val)==constant)
								fprintf(fcg,"li.s $f%d,%s\n",fl++,val);
							else if(Ref(val)==memory)
								fprintf(fcg,"l.s $f%d,%s\n",fl++,val);
							else
								fprintf(fcg,"mov.s $f%d,%s\n",fl++,val);
						}	
					}
					else
					{
						if(Ref(val)==constant)
							fprintf(fcg,"li $a%d,%s\n",nonfloat++,val);
						else if(Ref(val)==memory)
							fprintf(fcg,"lw $a%d,%s\n",nonfloat++,val);
						else
							fprintf(fcg,"move $a%d,%s\n",nonfloat++,val);
					}
				}
				fprintf(fcg,"\njal %s%d\n",m->name,m->number);
				char *temp=getNewTemp();
				int off=(temp[2]-'0')*10+temp[3]-'0';
				offset_temp[off]=-num_var*4;
				num_var++;
				if(tk)
				{
					if(tp!=tvoid &&(tp==tfloat || tp==tdouble))
						fprintf(fcg,"s.s $f0,%s\n",Address(temp));
					else if(tp!=tvoid)
						fprintf(fcg,"sw $v0,%s\n",Address(temp));
				}
				else
						fprintf(fcg,"sw $v0,%s\n",Address(temp));
				strcpy($$->contains,temp);
		}
		param.clear();	
	}
	|
	Identifier LRBRACE RRBRACE
	{
		$$=(struct attribute *)malloc(sizeof(struct attribute));
		struct ClassInterface *t=&listOfClasses[currenterpointer];
		bool found=false;
		int j;
		enum Basic tp=tvoid;
		char typ[1024];
		int tk=1;
		struct methodConstructor *m;
		while(t!=NULL && !found)
		{
			for(j=0;j<t->listOfMethods.size() && !found;j++)
			{
				if(strcmp(t->listOfMethods[j]->name,$1)==0 && t->listOfMethods[j]->param.size()==0)
				{		
					found=true;
					m=t->listOfMethods[j];		
					$$->dimension=0;
					if(t->listOfMethods[j]->token==1)
						tp=t->listOfMethods[j]->type;
					else
					{
						tk=0;
						strcpy(typ,t->listOfMethods[j]->ref);
					}
					if(find(returninfo->modifier.begin(),returninfo->modifier.end(),mstatic)!=returninfo->modifier.end())
					{
						if(find(t->listOfMethods[j]->modifier.begin(),t->listOfMethods[j]->modifier.end(),mstatic)==t->listOfMethods[j]->modifier.end())
							found=false;
					}
					if(t!=&listOfClasses[currenterpointer])
					{
						if(find(t->listOfMethods[j]->modifier.begin(),t->listOfMethods[j]->modifier.end(),mprivate)!=t->listOfMethods[j]->modifier.end())
							found=false;
					}
				}
			}
			t=t->extends;	
		}
		if(!found)
		{
			$$->type=tnone;
			printf("ERROR:Illegal method invocation at line %d\n",yylineno);
		}
		else
		{
			if(tk)
			{
				$$->token=1;	
				$$->type=tp;
			}
			else
			{
				strcpy($$->ref,typ);
				$$->token=2;
			}
				fprintf(fcg,"\njal %s%d\n",m->name,m->number);
				char *temp=getNewTemp();
				int off=(temp[2]-'0')*10+temp[3]-'0';
				offset_temp[off]=-num_var*4;
				num_var++;
				if(tk)
				{
					if(tp!=tvoid &&(tp==tfloat || tp==tdouble))
						fprintf(fcg,"s.s $f0,%s\n",Address(temp));
					else if(tp!=tvoid)
						fprintf(fcg,"sw $v0,%s\n",Address(temp));
				}
				else
						fprintf(fcg,"sw $v0,%s\n",Address(temp));
				strcpy($$->contains,temp);
		}
			
	}
	|
	Identifier DOT Identifier LRBRACE ArgumentList RRBRACE
	{
		$$=(struct attribute *)malloc(sizeof(struct attribute));
		bool found=false,isStatic=false;
		char name[1024];
		struct ClassInterface *t=&listOfClasses[0];
		ST *tab=currenter;
		STE *t1=(STE *)malloc(sizeof(STE));
		int loc=0;
		for(;loc<listOfClasses.size();loc++)
		{
			if(strcmp(listOfClasses[loc].name,$1)==0)
				break;
		}
		if(loc!=listOfClasses.size())
		{
			found=true;
			t=&listOfClasses[loc];
			isStatic=true;
		}
		else
		{
			while(tab!=NULL && !found)
			{
				t1=findentry(tab,$1);
				if(t1!=NULL)
					found=true;
				else
					tab=tab->prev;
			}
			if(found)
			{
				int i=0;
				while(i<listOfClasses.size())
				{
					if(t1->ref!=NULL && strcmp(t->name,t1->ref))
						i++;
					else
						break;
					t=&listOfClasses[i];
				}
			}	
		}
		if(!found)
		{
			//printf("%d %d\n",found,isStatic);
			$$->type=tnone;
			printf("ERROR:Illegal method access at line %d\n",yylineno);
		}
		else
		{
			bool found=false;
			int j,tk=1;
			enum Basic tp=tvoid;
			char typ[1024];
			struct methodConstructor *m;
			while(t!=NULL && !found)
			{
				for(j=0;j<t->listOfMethods.size() && !found;j++)
				{
					if(strcmp(t->listOfMethods[j]->name,$3)==0 && t->listOfMethods[j]->param.size()==param.size())
					{
						m=t->listOfMethods[j];
						if(t->listOfMethods[j]->token==1)
							tp=t->listOfMethods[j]->type;
						else
						{
							tk=0;
							strcpy(typ,t->listOfMethods[j]->ref);
						}
						$$->dimension=0;
						found=compare(t->listOfMethods[j]->param,param);
						if(isStatic)
						{
							if(find(t->listOfMethods[j]->modifier.begin(),t->listOfMethods[j]->modifier.end(),mstatic)==t->listOfMethods[j]->modifier.end())
								found=false;
						}
						if(t!=&listOfClasses[currenterpointer])
						{
							if(find(t->listOfMethods[j]->modifier.begin(),t->listOfMethods[j]->modifier.end(),mprivate)!=t->listOfMethods[j]->modifier.end())
								found=false;
						}
					}
				}
				t=t->extends;	
			}
			if(!found)
			{
				$$->type=tnone;
				printf("ERROR:Illegal method invocation at line %d\n",yylineno);
			}
			else
			{
				if(tk)
				{
					$$->token=1;	
					$$->type=tp;
				}
				else	
				{	
					strcpy($$->ref,typ);
					$$->token=2;
				}
					//printf("%d\n",tp);
					int nonfloat=0,fl=12;
					for(j=0;j<param.size();j++)		//currently restrciting to only 4 parameters
					{
						char *val=Address(param[j]->contains);
						if((m->param[j]->type==tfloat || m->param[j]->type==tdouble) && m->param[j]->token==1)
						{
							if(param[j]->type!=tfloat && param[j]->type!=tdouble)
							{
								if(Ref(val)==constant)
									fprintf(fcg,"li $t0,%s\n",val);
								else if(Ref(val)==memory)
									fprintf(fcg,"lw $t0,%s\n",val);
								else
									fprintf(fcg,"move $t0,%s\n",val);
								fprintf(fcg,"mtc1 $t0,$f1\n");
								fprintf(fcg,"cvt.s.w $f1,$f1\n");
								fprintf(fcg,"mov.s $f%d,$f1\n",fl++);
							}
							else
							{
								if(Ref(val)==constant)
									fprintf(fcg,"li.s $f%d,%s\n",fl++,val);
								else if(Ref(val)==memory)
									fprintf(fcg,"l.s $f%d,%s\n",fl++,val);
								else	
									fprintf(fcg,"mov.s $f%d,%s\n",fl++,val);
							}	
						}
						else
						{
							if(Ref(val)==constant)
								fprintf(fcg,"li $a%d,%s\n",nonfloat++,val);
							else if(Ref(val)==memory)
								fprintf(fcg,"lw $a%d,%s\n",nonfloat++,val);
							else
								fprintf(fcg,"move $a%d,%s\n",nonfloat++,val);
						}
					}
					char *temp=getNewTemp();
					int off=(temp[2]-'0')*10+temp[3]-'0';
					offset_temp[off]=-num_var*4;
					num_var++;
					if(!isStatic)
					{
						fprintf(fcg,"sw $s7,%s\n",Address(temp));
						fprintf(fcg,"lw $s7,%s\n",Address($1));
					}
					fprintf(fcg,"\njal %s%d\n",m->name,m->number);
					if(!isStatic)
						fprintf(fcg,"lw $s7,%s\n",Address(temp));
				if(tk)
				{
					if(tp!=tvoid &&(tp==tfloat || tp==tdouble))
						fprintf(fcg,"s.s $f0,%s\n",Address(temp));
					else if(tp!=tvoid)
						fprintf(fcg,"sw $v0,%s\n",Address(temp));
				}
				else
						fprintf(fcg,"sw $v0,%s\n",Address(temp));
					strcpy($$->contains,temp);
			}	
		}
		param.clear();
	}
	|
	Identifier DOT Identifier LRBRACE RRBRACE
	{
		$$=(struct attribute *)malloc(sizeof(struct attribute));
		bool found=false,isStatic=false;
		char name[1024];
		ST *tab=currenter;
		ClassInterface *t;
		STE *t1;
		int loc=0;
		for(;loc<listOfClasses.size();loc++)
		{
			if(strcmp(listOfClasses[loc].name,$1)==0)
				break;
		}
		if(loc!=listOfClasses.size())
		{
			found=true;
			isStatic=true;
			t=&listOfClasses[loc];
		}
		else
		{
			while(tab!=NULL && !found)
			{
				t1=findentry(tab,$1);
				if(t1!=NULL)
					found=true;
				else
					tab=tab->prev;
			}
			if(found)
			{
				int i=0;
				t=&listOfClasses[i];
				while(i<listOfClasses.size())
				{
					if(t1->ref!=NULL && strcmp(t->name,t1->ref))
						i++;
					else
						break;
					t=&listOfClasses[i];
				}
			}	
		}
		if(!found)
		{
			$$->type=tnone;
			printf("ERROR:Illegal method access at line %d\n",yylineno);
		}
		else
		{
			bool found=false;
			int j,tk=1;
			enum Basic tp=tvoid;
			char typ[1024];
			struct methodConstructor *m;
			while(t!=NULL && !found)
			{
				for(j=0;j<t->listOfMethods.size() && !found;j++)
				{
					$$->dimension=0;
					if(strcmp(t->listOfMethods[j]->name,$3)==0 && t->listOfMethods[j]->param.size()==0)
					{
						m=t->listOfMethods[j];		
						found=true;
						if(t->listOfMethods[j]->token==1)
							tp=t->listOfMethods[j]->type;
						else
						{
							tk=0;
							strcpy(typ,t->listOfMethods[j]->ref);
						}
						if(isStatic)
						{
							if(find(t->listOfMethods[j]->modifier.begin(),t->listOfMethods[j]->modifier.end(),mstatic)==t->listOfMethods[j]->modifier.end())
								found=false;
						}
						if(t!=&listOfClasses[currenterpointer])
						{
							if(find(t->listOfMethods[j]->modifier.begin(),t->listOfMethods[j]->modifier.end(),mprivate)!=t->listOfMethods[j]->modifier.end())
								found=false;
						}
					}
				}
				t=t->extends;	
			}
			if(!found)
			{
				$$->type=tnone;
				printf("ERROR:Illegal method invocation at line %d\n",yylineno);
			}
			else
			{
				if(tk)
				{
					$$->token=1;	
					$$->type=tp;
				}
				else	
				{	
					strcpy($$->ref,typ);
					$$->token=2;
				}
				
				char *temp=getNewTemp();
				int off=(temp[2]-'0')*10+temp[3]-'0';
				offset_temp[off]=-num_var*4;
				num_var++;
				if(!isStatic)
				{
					fprintf(fcg,"sw $s7,%s\n",Address(temp));
					fprintf(fcg,"lw $s7,%s\n",Address($1));
				}
				fprintf(fcg,"\njal %s%d\n",m->name,m->number);
				if(!isStatic)
					fprintf(fcg,"lw $s7,%s\n",Address(temp));
				if(tk)
				{
					if(tp!=tvoid &&(tp==tfloat || tp==tdouble))
						fprintf(fcg,"s.s $f0,%s\n",Address(temp));
					else if(tp!=tvoid)
						fprintf(fcg,"sw $v0,%s\n",Address(temp));
				}
				else
					fprintf(fcg,"sw $v0,%s\n",Address(temp));
				strcpy($$->contains,temp);
					
			}	
		}
	}
	| 
	Primary DOT Identifier LRBRACE ArgumentList RRBRACE	
	{
		$$=(struct attribute *)malloc(sizeof(struct attribute));
		if($1->token!=2)
		{
			$$->type=tnone;
			printf("ERROR:Illegal method invocation at line %d\n",yylineno);
		}
		else
		{
			struct ClassInterface *t;
			int p=currenterpointer;
			while(p>=0)
			{	
				t=&listOfClasses[p];
				if($1->ref!=NULL && !strcmp(t->name,$1->ref))
					break;
				else
					p--;
			}
			bool found=false;
			int j,tk=1;
			enum Basic tp=tvoid;
			char typ[1024];
			struct methodConstructor *m;
			while(t!=NULL && !found)
			{
				for(j=0;j<t->listOfMethods.size() && !found;j++)
				{
					if(strcmp(t->listOfMethods[j]->name,$3)==0 && t->listOfMethods[j]->param.size()==param.size())
					{
						m=t->listOfMethods[j];
						if(t->listOfMethods[j]->token==1)
							tp=t->listOfMethods[j]->type;
						else
						{
							tk=0;
							strcpy(typ,t->listOfMethods[j]->ref);
						}
						found=compare(t->listOfMethods[j]->param,param);
						if(t!=&listOfClasses[currenterpointer])
						{
							if(find(t->listOfMethods[j]->modifier.begin(),t->listOfMethods[j]->modifier.end(),mprivate)!=t->listOfMethods[j]->modifier.end())
								found=false;
						}
					}
				}		
				t=t->extends;	
			}
			if(!found)
			{
				$$->type=tnone;
				printf("ERROR:Illegal method invocation at line %d\n",yylineno);
			}
			else
			{
				if(tk)
				{
					$$->token=1;	
					$$->type=tp;
					int nonfloat=0,fl=12;
					for(j=0;j<param.size();j++)		//currently restrciting to only 4 parameters
					{
						char *val=Address(param[j]->contains);
						if((m->param[j]->type==tfloat || m->param[j]->type==tdouble) && m->param[j]->token==1)
						{
							if(param[j]->type!=tfloat && param[j]->type!=tdouble)
							{
								if(Ref(val)==constant)
									fprintf(fcg,"li $t0,%s\n",val);
								else if(Ref(val)==memory)
									fprintf(fcg,"lw $t0,%s\n",val);
								else
									fprintf(fcg,"move $t0,%s\n",val);
								fprintf(fcg,"mtc1 $t0,$f1\n");
								fprintf(fcg,"cvt.s.w $f1,$f1\n");
								fprintf(fcg,"mov.s $f%d,$f1\n",fl++);
							}
							else
							{
								if(Ref(val)==constant)
									fprintf(fcg,"li.s $f%d,%s\n",fl++,val);
								else if(Ref(val)==memory)
									fprintf(fcg,"l.s $f%d,%s\n",fl++,val);
								else	
									fprintf(fcg,"mov.s $f%d,%s\n",fl++,val);
							}	
						}
						else
						{
							if(Ref(val)==constant)
								fprintf(fcg,"li $a%d,%s\n",nonfloat++,val);
							else if(Ref(val)==memory)
								fprintf(fcg,"lw $a%d,%s\n",nonfloat++,val);
							else
								fprintf(fcg,"move $a%d,%s\n",nonfloat++,val);
						}
					}
					char *temp=getNewTemp();
					int off=(temp[2]-'0')*10+temp[3]-'0';
					offset_temp[off]=-num_var*4;
					num_var++;
					fprintf(fcg,"sw $s7,%s\n",Address(temp));
					if(Ref(Address($1->contains))==memory)
						fprintf(fcg,"lw $s7,%s\n",Address($1->contains));
					else
						fprintf(fcg,"move $s7,%s\n",Address($1->contains));
					fprintf(fcg,"\njal %s%d\n",m->name,m->number);
					fprintf(fcg,"lw $s7,%s\n",Address(temp));
					if(tk)
					{
						if(tp!=tvoid &&(tp==tfloat || tp==tdouble))
							fprintf(fcg,"s.s $f0,%s\n",Address(temp));
						else if(tp!=tvoid)
							fprintf(fcg,"sw $v0,%s\n",Address(temp));
					}
					else
						fprintf(fcg,"sw $v0,%s\n",Address(temp));
					strcpy($$->contains,temp);
				}
				else	
				{	
					strcpy($$->ref,typ);
					$$->token=2;
				}
			}
		}
		param.clear();	
	}
	|
	Primary DOT Identifier LRBRACE ArgumentList error SEMICOLON   {param.clear();printf("ERROR:Missing ) on line %d\n",yylineno);}
	|
	Primary DOT Identifier LRBRACE RRBRACE
	{
		$$=(struct attribute *)malloc(sizeof(struct attribute));
		if($1->token!=2)
		{
			$$->type=tnone;
			printf("ERROR:Illegal method access at line %d\n",yylineno);
		}
		else
		{
			struct ClassInterface *t;
			int p=currenterpointer;
			while(p>=0)
			{	
				t=&listOfClasses[p];
				if($1->ref!=NULL && !strcmp(t->name,$1->ref))
					break;
				else
					p--;
			}	
			bool found=false;
			int j,tk=1;
			enum Basic tp=tvoid;
			char typ[1024];
			struct methodConstructor *m;
			while(t!=NULL && !found)
			{
				for(j=0;j<t->listOfMethods.size() && !found;j++)
				{
					if(strcmp(t->listOfMethods[j]->name,$3)==0 && t->listOfMethods[j]->param.size()==0)
					{	
						m=t->listOfMethods[j];
						found=true;
						$$->dimension=0;
						if(t!=&listOfClasses[currenterpointer])
						{
							if(find(t->listOfMethods[j]->modifier.begin(),t->listOfMethods[j]->modifier.end(),mprivate)!=t->listOfMethods[j]->modifier.end())
								found=false;
						}
						if(t->listOfMethods[j]->token==1)
							tp=t->listOfMethods[j]->type;
						else
							{tk=0;	strcpy(typ,t->listOfMethods[j]->ref);}	
					}
				}
				t=t->extends;	
			}
			if(!found)
			{
				$$->type=tnone;
				printf("ERROR:Illegal method invocation at line %d\n",yylineno);
			}
			else
			{
				if(tk)
				{
					$$->token=1;	
					$$->type=tp;
				}
				else	
				{	
					strcpy($$->ref,typ);
					$$->token=2;
				}
					char *temp=getNewTemp();
					int off=(temp[2]-'0')*10+temp[3]-'0';
					offset_temp[off]=-num_var*4;
					num_var++;
					fprintf(fcg,"sw $s7,%s\n",Address(temp));
					if(Ref(Address($1->contains))==memory)
						fprintf(fcg,"lw $s7,%s\n",Address($1->contains));
					else
						fprintf(fcg,"move $s7,%s\n",Address($1->contains));
					fprintf(fcg,"\njal %s%d\n",m->name,m->number);
					fprintf(fcg,"lw $s7,%s\n",Address(temp));
					if(tp!=tvoid &&(tp==tfloat || tp==tdouble))
						fprintf(fcg,"s.s $f0,%s\n",Address(temp));
					else if(tp!=tvoid)
						fprintf(fcg,"sw $v0,%s\n",Address(temp));
					strcpy($$->contains,temp);
					
					if(tk)
					{
						if(tp!=tvoid &&(tp==tfloat || tp==tdouble))
							fprintf(fcg,"s.s $f0,%s\n",Address(temp));
						else if(tp!=tvoid)
							fprintf(fcg,"sw $v0,%s\n",Address(temp));
					}
					else
						fprintf(fcg,"sw $v0,%s\n",Address(temp));
			}
			
		}
	}	 	
	|
	Primary DOT Identifier LRBRACE error SEMICOLON		{printf("ERROR:Missing ) on line %d\n",yylineno);}
	|
	SUPER DOT Identifier LRBRACE ArgumentList RRBRACE
	{ 	$$=(struct attribute *)malloc(sizeof(struct attribute));
		struct ClassInterface *t=(struct ClassInterface *)malloc(sizeof(struct ClassInterface));
		t=listOfClasses[currenterpointer].extends;
		bool found=false;
		int j,tk=1;
		enum Basic tp=tvoid;
		char typ[1024];
		struct methodConstructor *m;
		while(t!=NULL && !found)
		{
			for(j=0;j<t->listOfMethods.size() && !found;j++)
			{
				if(strcmp(t->listOfMethods[j]->name,$3)==0 && t->listOfMethods[j]->param.size()==param.size())
				{
					m=t->listOfMethods[j];
					found=true;
					if(find(t->listOfMethods[j]->modifier.begin(),t->listOfMethods[j]->modifier.end(),mprivate)!=t->listOfMethods[j]->modifier.end())
						found=false;
					if(t->listOfMethods[j]->token==1)
						tp=t->listOfMethods[j]->type;
					else
					{tk=0;	strcpy(typ,t->listOfMethods[j]->ref);}	
					$$->dimension=0;
					found=compare(t->listOfMethods[j]->param,param);
				}
			}
			t=t->extends;	
		}
		if(!found)
		{
			$$->type=tnone;
			printf("ERROR:Illegal method invocation at line %d\n",yylineno);
		}
		else
		{
			if(tk)
			{
				$$->token=1;	
				$$->type=tp;
			}
			else	
			{	
				strcpy($$->ref,typ);
				$$->token=2;
			}
				int nonfloat=0,fl=12;
				for(j=0;j<param.size();j++)		//currently restrciting to only 4 parameters
				{
						char *val=Address(param[j]->contains);
						if((m->param[j]->type==tfloat || m->param[j]->type==tdouble) && m->param[j]->token==1)
						{
							if(param[j]->type!=tfloat && param[j]->type!=tdouble)
							{
								if(Ref(val)==constant)
									fprintf(fcg,"li $t0,%s\n",val);
								else if(Ref(val)==memory)
									fprintf(fcg,"lw $t0,%s\n",val);
								else
									fprintf(fcg,"move $t0,%s\n",val);
								fprintf(fcg,"mtc1 $t0,$f1\n");
								fprintf(fcg,"cvt.s.w $f1,$f1\n");
								fprintf(fcg,"mov.s $f%d,$f1\n",fl++);
							}
							else
							{
								if(Ref(val)==constant)
									fprintf(fcg,"li.s $f%d,%s\n",fl++,val);
								else if(Ref(val)==memory)
									fprintf(fcg,"l.s $f%d,%s\n",fl++,val);
								else	
									fprintf(fcg,"mov.s $f%d,%s\n",fl++,val);
							}	
						}
						else
						{
							if(Ref(val)==constant)
								fprintf(fcg,"li $a%d,%s\n",nonfloat++,val);
							else if(Ref(val)==memory)
								fprintf(fcg,"lw $a%d,%s\n",nonfloat++,val);
							else
								fprintf(fcg,"move $a%d,%s\n",nonfloat++,val);
						}
				}
				fprintf(fcg,"\njal %s%d\n",m->name,m->number);
				char *temp=getNewTemp();
				int off=(temp[2]-'0')*10+temp[3]-'0';
				offset_temp[off]=-num_var*4;
				num_var++;
				strcpy($$->contains,temp);
				
					if(tk)
					{
						if(tp!=tvoid &&(tp==tfloat || tp==tdouble))
							fprintf(fcg,"s.s $f0,%s\n",Address(temp));
						else if(tp!=tvoid)
							fprintf(fcg,"sw $v0,%s\n",Address(temp));
					}
					else
						fprintf(fcg,"sw $v0,%s\n",Address(temp));
		}
		param.clear();	
	}
	|
	SUPER DOT Identifier LRBRACE ArgumentList error SEMICOLON		{param.clear();printf("ERROR:Missing ) on line %d\n",yylineno);}
	|
	SUPER DOT Identifier LRBRACE RRBRACE
	{
		$$=(struct attribute *)malloc(sizeof(struct attribute));
		struct ClassInterface *t=listOfClasses[currenterpointer].extends;
		bool found=false;
		int j,tk=1;
		enum Basic tp=tvoid;
		char typ[1024];
		struct methodConstructor *m;
		while(t!=NULL && !found)
		{
			for(j=0;j<t->listOfMethods.size() && !found;j++)
			{
				if(strcmp(t->listOfMethods[j]->name,$3)==0 && t->listOfMethods[j]->param.size()==0)
				{	
					m=t->listOfMethods[j];
					found=true;
					if(find(t->listOfMethods[j]->modifier.begin(),t->listOfMethods[j]->modifier.end(),mprivate)!=t->listOfMethods[j]->modifier.end())
						found=false;
					if(t->listOfMethods[j]->token==1)
						tp=t->listOfMethods[j]->type;
					else
					{tk=0;	strcpy(typ,t->listOfMethods[j]->ref);}	
					$$->dimension=0;
				}
			}
			t=t->extends;	
		}
		if(!found)
		{
			$$->type=tnone;
			printf("ERROR:Illegal method invocation at line %d\n",yylineno);
		}
		else
		{
			if(tk)
			{
				$$->token=1;	
				$$->type=tp;
			}
			else	
			{	
				strcpy($$->ref,typ);
				$$->token=2;
			}
			
				fprintf(fcg,"\njal %s%d\n",m->name,m->number);
				char *temp=getNewTemp();
				int off=(temp[2]-'0')*10+temp[3]-'0';
				offset_temp[off]=-num_var*4;
				num_var++;
					if(tk)
					{
						if(tp!=tvoid &&(tp==tfloat || tp==tdouble))
							fprintf(fcg,"s.s $f0,%s\n",Address(temp));
						else if(tp!=tvoid)
							fprintf(fcg,"sw $v0,%s\n",Address(temp));
					}
					else
						fprintf(fcg,"sw $v0,%s\n",Address(temp));
				strcpy($$->contains,temp);
		}	
	}	 	
	|
	SUPER DOT Identifier LRBRACE error SEMICOLON			{printf("ERROR:Missing ) on line %d\n",yylineno);}
;
ArrayAccess:
	TypeName LSBRACE Expression RSBRACE
	{
		$$=(struct attribute *)malloc(sizeof(struct attribute));
		bool found=false;
		char name[1024];
		ST *tab=currenter;
		STE *t1=(STE *)malloc(sizeof(STE));
		while(tab!=NULL && !found)
		{
			t1=findentry(tab,$1->ref);
			if(t1!=NULL)
				found=true;
			else
				tab=tab->prev;
		}
		if(!found)
		{
			$$->type=tnone;
			printf("ERROR:Illegal array access at line %d\n",yylineno);
		}
		else
		{
			if(($3->type!=tint && $3->type!=tchar && $3->type!=tlong && $3->type!=tbyte && $3->type!=tshort) || t1->dimension==0)
			{
				$$->type=tnone;
				printf("ERROR:Wrong expression in array access at line %d\n",yylineno);
			}
			else
			{
				$$->dimension=t1->dimension-1;
				int nonstatic=1;
			       	if(t1->btype==tnone)
				{
					$$->token=t1->dimension>1?4:2;
					strcpy($$->ref,t1->ref);
					fprintf(fcg,"li $t0,%d\n",4*nonstatic);
				}
				else
				{
					$$->type=t1->btype;
					$$->token=t1->dimension>1?3:1;
					fprintf(fcg,"li $t0,4\n");
				}
				int start = t1->offset;
				char * val2 = Address($3->contains);
				enum refType type2 = Ref (val2);
				if (type2 == constant) 
					fprintf (fcg, "li $t1, %s\n", val2);
				else if (type2 == memory) 
					fprintf (fcg, "lw $t1, %s\n", val2);
				else 				
					fprintf (fcg, "move $t1, %s\n", val2);
				
				fprintf (fcg, "addi $t1, $t1, 1\n");
				
				fprintf (fcg, "mul $t0,$t0, $t1\n");
				if(Ref(Address($1->contains))==memory)
					fprintf (fcg, "lw $t1, %s\n",Address($1->contains));
				else
					fprintf (fcg, "move $t1, %s\n",Address($1->contains));
				fprintf (fcg, "add $t%d, $t0, $t1\n",next_loc_reg);
				fprintf (fcg, "\n");
				char temp[64];
					temp[0]='0';
					temp[1]='(';
					temp[2]='$';
					temp[3]='t';
					temp[4]='0'+next_loc_reg;
					temp[5]=')';
					temp[6]='\0';
					strcpy($$->contains,temp);
				next_loc_reg=(next_loc_reg+1)%10>=3?(next_loc_reg+1)%10:3;
			}
		}
	}
	|
	PrimaryNoNewArray LSBRACE Expression RSBRACE
	{	$$=(struct attribute *)malloc(sizeof(struct attribute));
		if($3->type!=tint && $3->type!=tlong && $3->type!=tbyte && $3->type!=tshort)
		{
			$$->type=tnone;
			printf("ERROR:Wrong expression in array access at line %d\n",yylineno);
		}
		else
		{
			if($1->dimension==0)
				printf("ERROR:Illegal array access at line %d\n",yylineno);
			else
			{
				if($1->token==1 || $1->token==3)
				{
					$$->token=$1->dimension>1?3:1;
					fprintf(fcg,"li $t0,%d\n",4);
					$$->type=$1->type;
				}
				else
				{
					$$->token=$1->dimension>1?4:2;
					fprintf(fcg,"li $t0,4\n");
					strcpy($$->ref,$1->ref);
				}
				char * val2 = Address($3->contains);
				enum refType type2 = Ref (val2);
				if (type2 == memory) 
					fprintf (fcg, "lw $t1, %s\n", val2);
				else if(type2==reg)				
					fprintf (fcg, "move $t1, %s\n", val2);
				else
					fprintf(fcg,"li $t1,%s\n",val2);
				fprintf (fcg, "addi $t1, $t1, 1\n");
				fprintf (fcg, "mul $t0,$t0, $t1\n");
				if(Ref(Address($1->contains))==memory)
					fprintf (fcg, "lw $t1, %s\n",Address($1->contains));
				else
					fprintf (fcg, "move $t1, %s\n",Address($1->contains));
				fprintf (fcg, "add $t%d, $t0, $t1\n",next_loc_reg);
				fprintf (fcg, "\n");
				char temp[64];
					temp[0]='0';
					temp[1]='(';
					temp[2]='$';
					temp[3]='t';
					temp[4]='0'+next_loc_reg;
					temp[5]=')';
					temp[6]='\0';
					strcpy($$->contains,temp);
				next_loc_reg=(next_loc_reg+1)%10>=3?(next_loc_reg+1)%10:3;
			}
		}
	}
	|
	PrimaryNoNewArray LSBRACE Expression error SEMICOLON { $$=(struct attribute *)malloc(sizeof(struct attribute));$$->type=tnone;printf("ERROR:Missing ] on line %d\n",yylineno);}
	|
	TypeName LSBRACE Expression error SEMICOLON	     { $$=(struct attribute *)malloc(sizeof(struct attribute));$$->type=tnone;printf("ERROR:Missing ] on line %d\n",yylineno);}
;
OpExpression:
	Primary				{$$=$1;}
	|
	Identifier
	{

		$$=(struct attribute *)malloc(sizeof(struct attribute));
		ST *temp=currenter;
		bool found=false;
		ClassInterface *t=&listOfClasses[currenterpointer];
		while(temp!=NULL)
		{
			if(!findentry(temp,$1))
			{
				temp=temp->prev;
				if(temp==NULL)
				{
					if(t->extends!=NULL)
					{
						temp=t->extends->table;
						t=t->extends;
					}
				}
			}
			else
			{
				STE *entry=findentry(temp,$1);
				found=true;
				if(temp==t->table)
				{
					if(find(returninfo->modifier.begin(),returninfo->modifier.end(),mstatic)==returninfo->modifier.end())
					{
						//printf("here\n");
						if(find(entry->modifiers.begin(),entry->modifiers.end(),mstatic)==entry->modifiers.end())
						{
							fprintf(fcg,"move $t0,$s7\n");
							int nonstatic=1,i=0,barrier=0,total=1;
							t=&listOfClasses[currenterpointer];
							temp=t->table;
							found=false;
					while(temp!=NULL)
					{
						for(i=0;i<temp->entries.size();i++)
						{
							if(find(temp->entries[i].modifiers.begin(),temp->entries[i].modifiers.end(),mstatic)==temp->entries[i].modifiers.end())
								total++;
						}
						if(t->extends!=NULL)
						{
							temp=t->extends->table;
							t=t->extends;
						}
						else
							temp=NULL;
					}
							t=&listOfClasses[currenterpointer];
							temp=t->table;
					while(temp!=NULL && !found)
					{
						nonstatic=0;
						for(i=0;i<temp->entries.size();i++)
						{
							if(find(temp->entries[i].modifiers.begin(),temp->entries[i].modifiers.end(),mstatic)==temp->entries[i].modifiers.end())
							{
								if(!strcmp(temp->entries[i].lexeme,$1))
								{
									found=true;
									break;
								}
								nonstatic++;
							}
						}
						barrier+=temp->entries.size();
						if(!found)
						{
							if(t->extends!=NULL)
							{
								temp=t->extends->table;
								t=t->extends;
							}
							else
								temp=NULL;
						}
					}
							fprintf(fcg,"addu $t0,$t0,%d\n",4*(nonstatic+total-barrier));
							fprintf(fcg,"move $t%d,$t0\n",next_loc_reg);
							fprintf(fcg,"\n");
							char temp[64];
							temp[0]='0';
							temp[1]='(';
							temp[2]='$';
							temp[3]='t';
							temp[4]='0'+next_loc_reg;
							temp[5]=')';
							temp[6]='\0';
							strcpy($$->contains,temp);
							next_loc_reg=(next_loc_reg+1)%10>=3?(next_loc_reg+1)%10:3;
						}
						else
							strcpy($$->contains,$1);
					}
					else
					{
						if(find(entry->modifiers.begin(),entry->modifiers.end(),mstatic)==entry->modifiers.end())
							printf("ERROR:call to a non static member from inside a static method\n");
						strcpy($$->contains,$1);
					}
				}
				else
					strcpy($$->contains,$1);
				if(entry->btype==tnone)
				{
					$$->token=entry->dimension>0?4:2;
					strcpy($$->ref,entry->ref);
				}
				else
				{
					$$->token=entry->dimension>0?3:1;
					$$->type=entry->btype;	
				}
				$$->dimension=entry->dimension;
				break;
			}
		}
		if(!found)
		{
			$$->type=tnone;
			printf("ERROR:Identifier at line %d not found\n",yylineno);
		}
		/*$$=(struct attribute *)malloc(sizeof(struct attribute));
		ST *temp=currenter;
		bool found=false;
		int val=currenterpointer;
		ClassInterface *t=&listOfClasses[currenterpointer];
		while(temp!=NULL)
		{
			if(!findentry(temp,$1))
			{
				temp=temp->prev;
				if(temp==NULL)
				{
					if(t->extends!=NULL)
					{
						temp=t->extends->table;
						t=t->extends;
					}
				}
			}
			else
			{
				STE *entry=findentry(temp,$1);
				found=true;
				if(temp==t->table)
				{
					if(find(returninfo->modifier.begin(),returninfo->modifier.end(),mstatic)==returninfo->modifier.end())
					{
						if(find(entry->modifiers.begin(),entry->modifiers.end(),mstatic)==entry->modifiers.end())
						{
							fprintf(fcg,"move $t0,$s7\n");
							int nonstatic=1,count=1,total=1,barrier=0,i=0;
							t=&listOfClasses[currenterpointer];
							temp=t->table;
							found=false;
							
				while(temp!=NULL)
				{
						for(i=0;i<temp->entries.size();i++)
						{
							if(find(temp->entries[i].modifiers.begin(),temp->entries[i].modifiers.end(),mstatic)==temp->entries[i].modifiers.end())
								total++;
						}
						if(t->extends!=NULL)
						{
							temp=t->extends->table;
							t=t->extends;
						}
						else
							temp=NULL;
				}
							t=&listOfClasses[currenterpointer];
							temp=t->table;
				while(temp!=NULL && !found)
				{
						nonstatic=0;
						for(i=0;i<temp->entries.size();i++)
						{
							if(find(temp->entries[i].modifiers.begin(),temp->entries[i].modifiers.end(),mstatic)==temp->entries[i].modifiers.end())
							{
								if(!strcmp(temp->entries[i].lexeme,$1))
								{
									found=true;
									break;
								}
								nonstatic++;
							}
						}
						barrier+=temp->entries.size();
						if(!found)
						{
							if(t->extends!=NULL)
							{
								temp=t->extends->table;
								t=t->extends;
							}
							else
								temp=NULL;
						}
				}
							printf("%d\n",nonstatic+total-barrier);
							fprintf(fcg,"addu $t0,$t0,%d\n",4*(nonstatic+total-barrier));
							fprintf(fcg,"move $t%d,$t0\n",next_loc_reg);
							fprintf(fcg,"\n");
							char temp[64];
							temp[0]='0';
							temp[1]='(';
							temp[2]='$';
							temp[3]='t';
							temp[4]='0'+next_loc_reg;
							temp[5]=')';
							temp[6]='\0';
							strcpy($$->contains,temp);
							next_loc_reg=(next_loc_reg+1)%10>=3?(next_loc_reg+1)%10:3;
						}
						else
							strcpy($$->contains,$1);
					}
					else
					{
						if(find(entry->modifiers.begin(),entry->modifiers.end(),mstatic)==entry->modifiers.end())
							printf("ERROR:call to a non static member from inside a static method\n");
						strcpy($$->contains,$1);
					}
				}
				else
					strcpy($$->contains,$1);
				if(entry->btype==tnone)
				{
					$$->token=entry->dimension>0?4:2;
					strcpy($$->ref,entry->ref);
				}
				else
				{
					$$->token=entry->dimension>0?3:1;
					$$->type=entry->btype;	
				}
				$$->dimension=entry->dimension;
				break;
			}
		}
		if(!found)
		{
			$$->type=tnone;
			printf("ERROR:-----Identifier at line %d not found\n",yylineno);
		}*/
	}	
	|
	PostFixOp			{$$=$1;}
;
PostFixOp:
	OpExpression UnaryRtoL		
	{	
		$$=new struct attribute;
		$$->dimension=0;
		$$->token=1;
		char *temp=getNewTemp();
		int off=(temp[2]-'0')*10+temp[3]-'0';
		offset_temp[off]=-num_var*4;
		num_var++;
		strcpy($$->contains,temp);
		char *val=Address($1->contains);
		enum refType t=Ref(val);
		if($1->token!=1)
			printf("ERROR:incorrect usage of postfix operator at line %d\n",yylineno);
		else
		{
			if($1->type==tdouble && !($1->type==tnull || $1->type==tboolean || $1->type==tvoid || $1->type==tnone))
			{
				if(t==constant)
				{
					$$->type=tnone;
					printf("ERROR:incorrect usage of postfix operator at line %d\n",yylineno);
				}
				else if(t==memory)
				{
					fprintf(fcg,"l.s $f0,%s\n",val);
					fprintf(fcg,"s.s $f0,%s\n",Address(temp));
					fprintf(fcg,"li.s $f1,1.0\n");
					fprintf(fcg,"%s.s $f0,$f0,$f1\n",$2);
					fprintf(fcg,"s.s $f0,%s\n",val);
					$$->type=tdouble;
				}
				else
				{
					fprintf(fcg,"mov.s $f0,%s\n",val);
					fprintf(fcg,"s.s $f0,%s\n",Address(temp));
					fprintf(fcg,"li.s $f1,1.0\n");
					fprintf(fcg,"%s.s $f0,$f0,$f1\n",$2);
					fprintf(fcg,"mov.s %s,$f0\n",val);
					$$->type=tdouble;
				}
			}
			else if($1->type==tfloat && !($1->type==tdouble || $1->type==tnull || $1->type==tboolean || $1->type==tvoid || $1->type==tnone))
			{
				if(t==constant)
				{
					$$->type=tnone;
					printf("ERROR:incorrect usage of postfix operator at line %d\n",yylineno);
				}
				else if(t==memory)
				{
					fprintf(fcg,"l.s $f0,%s\n",val);
					fprintf(fcg,"s.s $f0,%s\n",Address(temp));
					fprintf(fcg,"li.s $f1,1.0\n");
					fprintf(fcg,"%s.s $f0,$f0,$f1\n",$2);
					fprintf(fcg,"s.s $f0,%s\n",val);
					$$->type=tfloat;
				}
				else
				{
					fprintf(fcg,"mov.s $f0,%s\n",val);
					fprintf(fcg,"s.s $f0,%s\n",Address(temp));
					fprintf(fcg,"li.s $f0,1\n");
					fprintf(fcg,"%s.s $f0,$f0,$f1\n",$2);
					fprintf(fcg,"mov.s %s,$f0\n",val);
					$$->type=tdouble;
				}
				
			}
			else if($1->type==tlong && !($1->type==tfloat || $1->type==tdouble || $1->type==tnull || $1->type==tboolean || $1->type==tvoid || $1->type==tnone))
			{
				if(t==constant)
				{
					$$->type=tnone;
					printf("ERROR:incorrect usage of postfix operator at line %d\n",yylineno);
				}
				else if(t==memory)
				{
					fprintf(fcg,"lw $t0,%s\n",val);
					fprintf(fcg,"sw $t0,%s\n",Address(temp));
					fprintf(fcg,"%s $t0,$t0,1\n",$2);
					fprintf(fcg,"sw $t0,%s\n",val);
					$$->type=tlong;
				}
				else
				{
					fprintf(fcg,"move $t0,%s\n",val);
					fprintf(fcg,"sw $t0,%s\n",Address(temp));
					fprintf(fcg,"%s $t0,$t0,1\n",$2);
					fprintf(fcg,"move %s,$t0\n",val);
					$$->type=tlong;
				}
				
			}
			else if($1->type==tint && ($1->type==tint || $1->type==tbyte || $1->type==tshort || $1->type==tchar))
			{
				if(t==constant)
				{
					$$->type=tnone;
					printf("ERROR:incorrect usage of postfix operator at line %d\n",yylineno);
				}
				else if(t==memory)
				{
					fprintf(fcg,"lw $t0,%s\n",val);
					fprintf(fcg,"sw $t0,%s\n",Address(temp));
					fprintf(fcg,"%s $t0,$t0,1\n",$2);
					fprintf(fcg,"sw $t0,%s\n",val);
					$$->type=tint;
				}
				else
				{
					fprintf(fcg,"move $t0,%s\n",val);
					fprintf(fcg,"sw $t0,%s\n",Address(temp));
					fprintf(fcg,"%s $t0,$t0,1\n",$2);
					fprintf(fcg,"move %s,$t0\n",val);
					$$->type=tint;
				}
			}
			else if($1->type==tshort && ($1->type==tbyte || $1->type==tshort))
			{
				if(t==constant)
				{
					$$->type=tnone;
					printf("ERROR:incorrect usage of postfix operator at line %d\n",yylineno);
				}
				else if(t==memory)
				{
					fprintf(fcg,"lw $t0,%s\n",val);
					fprintf(fcg,"sw $t0,%s\n",Address(temp));
					fprintf(fcg,"%s $t0,$t0,1\n",$2);
					fprintf(fcg,"sw $t0,%s\n",val);
					$$->type=tshort;
				}
				else
				{
					fprintf(fcg,"move $t0,%s\n",val);
					fprintf(fcg,"sw $t0,%s\n",Address(temp));
					fprintf(fcg,"%s $t0,$t0,1\n",$2);
					fprintf(fcg,"move %s,$t0\n",val);
					$$->type=tshort;
				}
			}
			else if($1->type==tbyte && $1->type==tbyte)
			{
				if(t==constant)
				{
					$$->type=tnone;
					printf("ERROR:incorrect usage of postfix operator at line %d\n",yylineno);
				}
				else if(t==memory)
				{
					fprintf(fcg,"lw $t0,%s\n",val);
					fprintf(fcg,"sw $t0,%s\n",Address(temp));
					fprintf(fcg,"%s $t0,$t0,1\n",$2);
					fprintf(fcg,"sw $t0,%s\n",val);
					$$->type=tbyte;
				}
				else
				{
					fprintf(fcg,"move $t0,%s\n",val);
					fprintf(fcg,"sw $t0,%s\n",Address(temp));
					fprintf(fcg,"%s $t0,$t0,1\n",$2);
					fprintf(fcg,"move %s,$t0\n",val);
					$$->type=tbyte;
				}
			}
			else if($1->type==tchar && $1->type==tchar)
			{
				if(t==constant)
				{
					$$->type=tnone;
					printf("ERROR:incorrect usage of postfix operator at line %d\n",yylineno);
				}
				else if(t==memory)
				{
					fprintf(fcg,"lb $t0,%s\n",val);
					fprintf(fcg,"sb $t0,%s\n",Address(temp));
					fprintf(fcg,"%s $t0,$t0,1\n",$2);
					fprintf(fcg,"sb $t0,%s\n",val);
					$$->type=tchar;
				}
				else
				{
					fprintf(fcg,"move $t0,%s\n",val);
					fprintf(fcg,"sb $t0,%s\n",Address(temp));
					fprintf(fcg,"%s $t0,$t0,1\n",$2);
					fprintf(fcg,"move %s,$t0\n",val);
					$$->type=tchar;
				}
			}
			else
			{
				printf("ERROR:incorrect usage of postfix operator on line %d\n",yylineno);
				$$->type=tnone;
			}
		}			
	}
;
UnaryExpression:
	OpExpression			{$$=$1;}
	|
	UnaryLtoR UnaryExpression	
	{
		$$=new struct attribute;
		$$->token=1;
		$$->dimension=0;
		char *temp,*val=Address($2->contains);
		if(val[0]=='_' && val[1]=='T')
			temp=val;
		else
		{	
			temp=getNewTemp();
			int off=(temp[2]-'0')*10+temp[3]-'0';
			offset_temp[off]=-num_var*4;
			num_var++;
		}
		strcpy($$->contains,temp);
		enum refType t=Ref(val);
		if($2->token!=1)
			printf("ERROR:incorrect usage of unary operator on line %d\n",yylineno);
		else
		{
			if(!strcmp($1,"neg") || !strcmp($1,"not"))
			{
				if($2->type==tdouble || $2->type==tfloat) 
				{
					if(t==constant)
					{
						fprintf(fcg,"li.s $f0,%s\n",val);
						fprintf(fcg,"%s.s $f0,$f0\n",$1);
						fprintf(fcg,"s.s $f0,%s\n",Address(temp));
					}
					else if(t==memory)
					{
						fprintf(fcg,"l.s $f0,%s\n",val);
						fprintf(fcg,"%s.s $f0,$f0\n",$1);
						fprintf(fcg,"s.s $f0,%s\n",Address(temp));
					}
					else
					{
						fprintf(fcg,"mov.s $f0,%s\n",val);
						fprintf(fcg,"%s.s $f0,$f0\n",$1);
						fprintf(fcg,"mov.s %s,$f0\n",Address(temp));
					}
					$$->type=$2->type;
				}
				else if($2->type!=tboolean && $2->type!=tnone && $2->type!=tvoid)
				{
					if(t==constant)
					{
						fprintf(fcg,"li $t0,%s\n",val);
						fprintf(fcg,"%s $t0,$t0\n",$1);
						fprintf(fcg,"sw $t0,%s\n",Address(temp));
					}
					else if(t==memory)
					{
						fprintf(fcg,"lw $t0,%s\n",val);
						fprintf(fcg,"%s $t0,$t0\n",$1);
						fprintf(fcg,"sw $t0,%s\n",Address(temp));
					}
					else
					{
						fprintf(fcg,"move $t0,%s\n",val);
						fprintf(fcg,"%s $t0,$t0\n",$1);
						fprintf(fcg,"move %s,$t0\n",Address(temp));
					}
					$$->type=$2->type;
				}
				else
				{
					printf("ERROR:incorrect usage of unary operator on line %d\n",yylineno);
					$$->type=tnone;
				}
			}
			else if(!strcmp($1,"bnot"))
			{
				if($2->type==tboolean)
				{
					if(t==constant)
					{
						fprintf(fcg,"li $t0,%s\n",val);
						fprintf(fcg,"seq $t0,$t0,0\n");
						fprintf(fcg,"sw $t0,%s\n",Address(temp));
					}
					else if(t==memory)
					{
						fprintf(fcg,"lw $t0,%s\n",val);
						fprintf(fcg,"seq $t0,$t0,0\n");
						fprintf(fcg,"sw $t0,%s\n",Address(temp));
					}
					else
					{
						fprintf(fcg,"move $t0,%s\n",val);
						fprintf(fcg,"seq $t0,$t0,0\n");
						fprintf(fcg,"move %s,$t0\n",Address(temp));
					}
					$$->type=tboolean;
				}
				else
				{
					printf("ERROR:incorrect usage of not operator on line %d\n",yylineno);
					$$->type=tnone;
				}
			}
			else
			{
				if($2->type==tdouble || $2->type==tfloat) 
				{
					if(t==constant)
					{
						fprintf(fcg,"li.s $f0,%s\n",val);
						fprintf(fcg,"s.s $f0,%s\n",Address(temp));
					}
					else if(t==memory)
					{
						fprintf(fcg,"l.s $f0,%s\n",val);
						fprintf(fcg,"s.s $f0,%s\n",Address(temp));
					}
					else
						fprintf(fcg,"mov.s %s,%s\n",Address(temp),val);
					$$->type=$2->type;
				}
				else if($2->type!=tboolean && $2->type!=tnone && $2->type!=tvoid && $2->type!=tnull)
				{
					if(t==constant)
					{
						fprintf(fcg,"li $t0,%s\n",val);
						fprintf(fcg,"sw $t0,%s\n",Address(temp));
					}
					else if(t==memory)
					{
						fprintf(fcg,"lw $t0,%s\n",val);
						fprintf(fcg,"sw $t0,%s\n",Address(temp));
					}
					else
						fprintf(fcg,"move %s,%s\n",Address(temp),val);
					$$->type=$2->type;
				}
				else
				{
					printf("ERROR:incorrect usage of unary operator on line %d\n",yylineno);
					$$->type=tnone;
				}
			}
				
		}
	}
	|
	Cast UnaryExpression	/*how to cast?*/
	{
		$$=new struct attribute;
		$$=$2;
		$$->type=$1->type;
	}
	|
	PreFixOp			{$$=$1;}
	|
	UnaryLtoR error SEMICOLON	{ $$=(struct attribute *)malloc(sizeof(struct attribute));$$->type=tnone;printf("ERROR:Error in unary expression at line %d\n",yylineno);}
;
PreFixOp:
	UnaryRtoL %prec PREINCREMENT UnaryExpression
	{	
		$$=new struct attribute;
		$$->dimension=0;
		$$->token=1;
		strcpy($$->contains,$2->contains);
		char *val=Address($2->contains);
		enum refType t=Ref(val);
		if($2->token!=1)
			printf("ERROR:incorrect usage of postfix operator at line %d\n",yylineno);
		else
		{
			if($2->type==tdouble || $2->type==tfloat)
			{
				if(t==constant)
				{
					$$->type=tnone;
					printf("ERROR:incorrect usage of postfix operator at line %d\n",yylineno);
				}
				else if(t==memory)
				{
					fprintf(fcg,"l.s $f0,%s\n",val);
					fprintf(fcg,"li.s $f1,1.0\n");
					fprintf(fcg,"%s.s $f0,$f0,$f1\n",$1);
					fprintf(fcg,"s.s $f0,%s\n",val);
					$$->type=$2->type;
				}
				else
				{
					fprintf(fcg,"mov.s $f0,%s\n",val);
					fprintf(fcg,"li.s $f1,1.0\n");
					fprintf(fcg,"%s.s $f0,$f0,$f1\n",$1);
					fprintf(fcg,"mov.s %s,$f0\n",val);
					$$->type=$2->type;
				}
			}
			else if($2->type!=tboolean && $2->type!=tnone && $2->type!=tvoid && $2->type!=tnull)
			{
				if(t==constant)
				{
					$$->type=tnone;
					printf("ERROR:incorrect usage of postfix operator at line %d\n",yylineno);
				}
				else if(t==memory)
				{
					fprintf(fcg,"lw $t0,%s\n",val);
					fprintf(fcg,"%s $t0,$t0,1\n",$1);
					fprintf(fcg,"sw $t0,%s\n",val);
					$$->type=$2->type;
				}
				else
				{
					fprintf(fcg,"move $t0,%s\n",val);
					fprintf(fcg,"%s $t0,$t0,1\n",$1);
					fprintf(fcg,"move %s,$t0\n",val);
					$$->type=$2->type;
				}
			}
			else
			{
				printf("ERROR:incorrect usage of postfix operator on line %d\n",yylineno);
				$$->type=tnone;
			}
		}			
	}
;
MultExpression:
	MultExpression MultOperator UnaryExpression
	{	$$=(struct attribute *)malloc(sizeof(struct attribute));
		$$->token=1;
		$$->dimension=0;

		char *val1=Address($1->contains);
		char *val2=Address($3->contains);
		char *temp;
		if($1->contains[0]=='_' && $1->contains[1]=='T')
			temp=val1;
		else if($3->contains[0]=='_' && $3->contains[1]=='T')
			temp=val2;
		else
		{	
			temp=getNewTemp();
			int off=(temp[2]-'0')*10+temp[3]-'0';
			offset_temp[off]=-num_var*4;
			num_var++;
		}
		strcpy($$->contains,temp);
		char *val3=Address(temp);
		enum refType t1=Ref(val1);
		enum refType t2=Ref(val2);
		//printf("%d %d\n",$1->type,$3->type);
		if($1->type==tdouble && $3->type!=tstring && $3->type!=tboolean && $3->type!=tnull && $3->type!=tvoid && $3->type!=tnone)
		{
			if(t1==constant)
				fprintf(fcg,"li.s $f0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"l.s $f0,%s\n",val1);
			else
				fprintf(fcg,"mov.s $f0,%s\n",val1);
			if($3->type!=tdouble && $3->type!=tfloat)
			{
				if(t2==constant)
					fprintf(fcg,"li $t0,%s\n",val2);
				else if(t2==memory)
					fprintf(fcg,"lw $t0,%s\n",val2);
				else
					fprintf(fcg,"move $t0,%s\n",val2);
				fprintf(fcg,"mtc1 $t0,$f1\n");
				fprintf(fcg,"cvt.s.w $f1,$f1\n");
			}
			else
			{
				if(t2==constant)
					fprintf(fcg,"li.s $f1,%s\n",val2);
				else if(t2==memory)
					fprintf(fcg,"l.s $f1,%s\n",val2);
				else
					fprintf(fcg,"mov.s $f1,%s\n",val2);
			}
			if(!strcmp($2,"rem"))
				printf("ERROR:mod operator on floating point not supported\n");
			fprintf(fcg,"%s.s $f1,$f0,$f1\n",$2);
			fprintf(fcg,"s.s $f1,%s\n",val3);
			$$->type=tdouble;
		}
		else if($1->type==tfloat && $3->type!=tdouble \
		&& $3->type!=tstring && $3->type!=tboolean && $3->type!=tnull && $3->type!=tvoid && $3->type!=tnone)
		{
			if(t1==constant)
				fprintf(fcg,"li.s $f0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"l.s $f0,%s\n",val1);
			else
				fprintf(fcg,"mov.s $f0,%s\n",val1);
			if($3->type!=tdouble && $3->type!=tfloat)
			{
				if(t2==constant)
					fprintf(fcg,"li $t0,%s\n",val2);
				else if(t2==memory)
					fprintf(fcg,"lw $t0,%s\n",val2);
				else
					fprintf(fcg,"move $t0,%s\n",val2);
				fprintf(fcg,"mtc1 $t0,$f1\n");
				fprintf(fcg,"cvt.s.w $f1,$f1\n");
			}
			else
			{
				if(t2==constant)
					fprintf(fcg,"li.s $f1,%s\n",val2);
				else if(t2==memory)
					fprintf(fcg,"l.s $f1,%s\n",val2);
				else 
					fprintf(fcg,"mov.s $f1,%s\n",val2);
			}
			fprintf(fcg,"%s.s $f1,$f0,$f1\n",$2);
			if(!strcmp($2,"rem"))
				printf("ERROR:mod operator on floating point not supported\n");
			fprintf(fcg,"s.s $f1,%s\n",val3);
			$$->type=tfloat;			
		}
		else if($1->type==tlong && ($3->type==tlong || $3->type==tint || $3->type==tbyte || $3->type==tshort || $3->type==tchar))
		{
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else 
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
                        $$->type=tlong;
		}
                else if($1->type==tint && ($3->type==tint || $3->type==tbyte || $3->type==tshort || $3->type==tchar))
		{
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
                        $$->type=tint;
		}
                else if($1->type==tshort && ($3->type==tbyte || $3->type==tshort))
		{
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else 
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else 
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
                        $$->type=tshort;
		}
                else if($1->type==tbyte && $3->type==tbyte )
		{
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else 
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
                        $$->type=tbyte;
		}
                else if($1->type==tchar && $3->type==tchar)
		{
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lb $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lb $t1,%s\n",val2);
			else 
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sb $t0,%s\n",val3);
                        $$->type=tchar;
		}	
		else if($3->type==tdouble && $1->type!=tstring && $1->type!=tboolean && $1->type!=tnull && $1->type!=tvoid && $1->type!=tnone)
		{
			if(t2==constant)
				fprintf(fcg,"li.s $f0,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"l.s $f0,%s\n",val2);
			else 
				fprintf(fcg,"mov.s $f0,%s\n",val2);
			if($1->type!=tdouble && $1->type!=tfloat)
			{
				if(t1==constant)
					fprintf(fcg,"li $t0,%s\n",val1);
				else if(t1==memory)
					fprintf(fcg,"lw $t0,%s\n",val1);
				else 
					fprintf(fcg,"move $t0,%s\n",val1);
				fprintf(fcg,"mtc1 $t0,$f1\n");
				fprintf(fcg,"cvt.s.w $f1,$f1\n");
			}
			else
			{
				if(t1==constant)
					fprintf(fcg,"li.s $f1,%s\n",val1);
				else if(t1==memory)
					fprintf(fcg,"l.s $f1,%s\n",val1);
				else
					fprintf(fcg,"mov.s $f1,%s\n",val1);
			}
			fprintf(fcg,"%s.s $f1,$f1,$f0\n",$2);
			fprintf(fcg,"s.s $f1,%s\n",val3);
			$$->type=tdouble;
		}
		else if($3->type==tfloat && $1->type!=tdouble && $1->type!=tstring && $1->type!=tboolean \
		&& $1->type!=tnull && $1->type!=tvoid && $1->type!=tnone) 
		{
			if(t2==constant)
				fprintf(fcg,"li.s $f0,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"l.s $f0,%s\n",val2);
			else
				fprintf(fcg,"mov.s $f0,%s\n",val2);
			if($1->type!=tdouble && $1->type!=tfloat)
			{
				if(t1==constant)
					fprintf(fcg,"li $t0,%s\n",val1);
				else if(t1==memory)
					fprintf(fcg,"lw $t0,%s\n",val1);
				else
					fprintf(fcg,"move $t0,%s\n",val1);
				fprintf(fcg,"mtc1 $t0,$f1\n");
				fprintf(fcg,"cvt.s.w $f1,$f1\n");
			}
			else
			{
				if(t1==constant)
					fprintf(fcg,"li.s $f1,%s\n",val1);
				else if(t1==memory)
					fprintf(fcg,"l.s $f1,%s\n",val1);
				else
					fprintf(fcg,"mov.s $f1,%s\n",val1);
			}
			fprintf(fcg,"%s.s $f1,$f1,$f0\n",$2);
			fprintf(fcg,"s.s $f1,%s\n",val3);
			$$->type=tfloat;
		}
		else if($3->type==tlong && ($1->type==tlong || $1->type==tint || $1->type==tbyte || $1->type==tshort || $1->type==tchar))
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
                        $$->type=tlong;
		}
                else if($3->type==tint && ($1->type==tint || $1->type==tbyte || $1->type==tshort || $1->type==tchar))
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
                        $$->type=tint;
		}
                else if($3->type==tshort && ($1->type==tbyte || $1->type==tshort))
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
                        $$->type=tshort;
		}
                else if($3->type==tbyte && $1->type==tbyte)
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else 
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
                        $$->type=tbyte;
		}
                else if($3->type==tchar && $1->type==tchar)
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lb $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lb $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sb $t0,%s\n",val3);
                        $$->type=tchar;
		}
                else
                {
                        printf("ERROR:Incorrect usage of *,divide or mod on line %d\n",yylineno);
                        $$->type=tnone;
                }
	}
	|
	UnaryExpression		{$$=$1;}
	|
	MultExpression MultOperator error SEMICOLON {$$=(struct attribute *)malloc(sizeof(struct attribute));$$->type=tnone;printf("ERROR:Error in expression at line %d\n",yylineno);}
;
AddExpression:
	AddExpression AddOperator MultExpression	
	{	$$=(struct attribute *)malloc(sizeof(struct attribute));
		$$->token=1;
		$$->dimension=0;
		char *val1=Address($1->contains);
		char *val2=Address($3->contains);
		char *temp;
		if($1->contains[0]=='_' && $1->contains[1]=='T')
			temp=val1;
		else if($3->contains[0]=='_' && $3->contains[1]=='T')
			temp=val2;
		else
		{	
			temp=getNewTemp();
			int off=(temp[2]-'0')*10+temp[3]-'0';
			offset_temp[off]=-num_var*4;
			num_var++;
		}
		strcpy($$->contains,temp);
		char *val3=Address(temp);
		enum refType t1=Ref(val1);
		enum refType t2=Ref(val2);
	
		if($1->type==tdouble && $3->type!=tstring && $3->type!=tboolean && $3->type!=tnull && $3->type!=tvoid && $3->type!=tnone)
		{
			if(t1==constant)
				fprintf(fcg,"li.s $f0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"l.s $f0,%s\n",val1);
			else
				fprintf(fcg,"mov.s $f0,%s\n",val1);
			if($3->type!=tdouble && $3->type!=tfloat)
			{
				if(t2==constant)
					fprintf(fcg,"li $t0,%s\n",val2);
				else if(t2==memory)
					fprintf(fcg,"lw $t0,%s\n",val2);
				else
					fprintf(fcg,"move $t0,%s\n",val2);
				fprintf(fcg,"mtc1 $t0,$f1\n");
				fprintf(fcg,"cvt.s.w $f1,$f1\n");
			}
			else
			{
				if(t2==constant)
					fprintf(fcg,"li.s $f1,%s\n",val2);
				else if(t2==memory)
					fprintf(fcg,"l.s $f1,%s\n",val2);
				else
					fprintf(fcg,"mov.s $f1,%s\n",val2);
			}
			fprintf(fcg,"%s.s $f1,$f0,$f1\n",$2);
			fprintf(fcg,"s.s $f1,%s\n",val3);
			$$->type=tdouble;
		}
		else if($1->type==tfloat && $3->type!=tdouble \
		&& $3->type!=tstring && $3->type!=tboolean && $3->type!=tnull && $3->type!=tvoid && $3->type!=tnone)
		{
			if(t1==constant)
				fprintf(fcg,"li.s $f0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"l.s $f0,%s\n",val1);
			else
				fprintf(fcg,"mov.s $f0,%s\n",val1);
			if($3->type!=tdouble && $3->type!=tfloat)
			{
				if(t2==constant)
					fprintf(fcg,"li $t0,%s\n",val2);
				else if(t2==memory)
					fprintf(fcg,"lw $t0,%s\n",val2);
				else
					fprintf(fcg,"move $t0,%s\n",val2);
				fprintf(fcg,"mtc1 $t0,$f1\n");
				fprintf(fcg,"cvt.s.w $f1,$f1\n");
			}
			else
			{
				if(t2==constant)
					fprintf(fcg,"li.s $f1,%s\n",val2);
				else if(t2==memory)
					fprintf(fcg,"l.s $f1,%s\n",val2);
				else
					fprintf(fcg,"mov.s $f1,%s\n",val2);
			}
			fprintf(fcg,"%s.s $f1,$f0,$f1\n",$2);
			fprintf(fcg,"s.s $f1,%s\n",val3);
			$$->type=tfloat;			
		}
		else if($1->type==tlong && ($3->type==tlong || $3->type==tint || $3->type==tbyte || $3->type==tshort || $3->type==tchar))
		{
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
                        $$->type=tlong;
		}
                else if($1->type==tint && ($3->type==tint || $3->type==tbyte || $3->type==tshort || $3->type==tchar))
		{
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
                        $$->type=tint;
		}
                else if($1->type==tshort && ($3->type==tbyte || $3->type==tshort))
		{
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
                        $$->type=tshort;
		}
                else if($1->type==tbyte && $3->type==tbyte )
		{
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
                        $$->type=tbyte;
		}
                else if($1->type==tchar && $3->type==tchar)
		{
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lb $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lb $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sb $t0,%s\n",val3);
                        $$->type=tchar;
		}	
		else if($3->type==tdouble && $1->type!=tstring && $1->type!=tboolean && $1->type!=tnull && $1->type!=tvoid && $1->type!=tnone)
		{
			if(t2==constant)
				fprintf(fcg,"li.s $f0,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"l.s $f0,%s\n",val2);
			else
				fprintf(fcg,"mov.s $f0,%s\n",val2);
			if($1->type!=tdouble && $1->type!=tfloat)
			{
				if(t1==constant)
					fprintf(fcg,"li $t0,%s\n",val1);
				else if(t1==memory)
					fprintf(fcg,"lw $t0,%s\n",val1);
				else
					fprintf(fcg,"move $t0,%s\n",val1);
				fprintf(fcg,"mtc1 $t0,$f1\n");
				fprintf(fcg,"cvt.s.w $f1,$f1\n");
			}
			else
			{
				if(t1==constant)
					fprintf(fcg,"li.s $f1,%s\n",val1);
				else if(t1==memory)
					fprintf(fcg,"l.s $f1,%s\n",val1);
				else
					fprintf(fcg,"mov.s $f1,%s\n",val1);
			}
			fprintf(fcg,"%s.s $f1,$f1,$f0\n",$2);
			fprintf(fcg,"s.s $f1,%s\n",val3);
			$$->type=tdouble;
		}
		else if($3->type==tfloat && $1->type!=tdouble && $1->type!=tstring && $1->type!=tboolean \
		&& $1->type!=tnull && $1->type!=tvoid && $1->type!=tnone) 
		{
			if(t2==constant)
				fprintf(fcg,"li.s $f0,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"l.s $f0,%s\n",val2);
			else
				fprintf(fcg,"mov.s $f0,%s\n",val2);
			if($1->type!=tdouble && $1->type!=tfloat)
			{
				if(t1==constant)
					fprintf(fcg,"li $t0,%s\n",val1);
				else if(t1==memory)
					fprintf(fcg,"lw $t0,%s\n",val1);
				else
					fprintf(fcg,"move $t0,%s\n",val1);
				fprintf(fcg,"mtc1 $t0,$f1\n");
				fprintf(fcg,"cvt.s.w $f1,$f1\n");
			}
			else
			{
				if(t1==constant)
					fprintf(fcg,"li.s $f1,%s\n",val1);
				else if(t1==memory)
					fprintf(fcg,"l.s $f1,%s\n",val1);
				else
					fprintf(fcg,"mov.s $f1,%s\n",val1);
			}
			fprintf(fcg,"%s.s $f1,$f1,$f0\n",$2);
			fprintf(fcg,"s.s $f1,%s\n",val3);
			$$->type=tfloat;
		}
		else if($3->type==tlong && ($1->type==tlong || $1->type==tint || $1->type==tbyte || $1->type==tshort || $1->type==tchar))
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
                        $$->type=tlong;
		}
                else if($3->type==tint && ($1->type==tint || $1->type==tbyte || $1->type==tshort || $1->type==tchar))
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
                        $$->type=tint;
		}
                else if($3->type==tshort && ($1->type==tbyte || $1->type==tshort))
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
                        $$->type=tshort;
		}
                else if($3->type==tbyte && $1->type==tbyte)
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
                        $$->type=tbyte;
		}
                else if($3->type==tchar && $1->type==tchar)
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lb $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lb $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sb $t0,%s\n",val3);
                        $$->type=tchar;
		}
		else if($1->ref!=NULL && $3->ref!=NULL && !strcmp($1->ref,"String")  && !strcmp($3->ref,"String"))
		{
			$$->token=2;
			strcpy($$->ref,"String");			/*How to do string concatenation?*/
		}
                else
                {
                        printf("ERROR:Incorrect usage of +/- line %d\n",yylineno);
                        $$->type=tnone;
                }
	}
	|
	MultExpression		{$$=$1;}
	|
	AddExpression AddOperator error SEMICOLON	{$$=(struct attribute *)malloc(sizeof(struct attribute));$$->type=tnone;printf("Error in expression at line %d\n",yylineno);}
;
ShiftExpression:
	ShiftExpression ShiftOperator AddExpression	
	{	$$=(struct attribute *)malloc(sizeof(struct attribute));
		$$->token=1;
		$$->dimension=0;

		
		char *val1=Address($1->contains);
		char *val2=Address($3->contains);
		char *temp;
		if($1->contains[0]=='_' && $1->contains[1]=='T')
			temp=val1;
		else if($3->contains[0]=='_' && $3->contains[1]=='T')
			temp=val2;
		else
		{	
			temp=getNewTemp();
			int off=(temp[2]-'0')*10+temp[3]-'0';
			offset_temp[off]=-num_var*4;
			num_var++;
		}
		strcpy($$->contains,temp);
		char *val3=Address(temp);
		enum refType t1=Ref(val1);
		enum refType t2=Ref(val2);
	
		if($1->type==tlong && ($3->type==tlong || $3->type==tint || $3->type==tbyte || $3->type==tshort))
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
			$$->type=tlong;
		}				
                else if($1->type==tint && ($3->type==tint || $3->type==tbyte || $3->type==tshort))
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
			$$->type=tint;
		}
                else if($1->type==tshort && ($3->type==tbyte || $3->type==tshort))
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
			$$->type=tshort;
		}
                else if($1->type==tbyte && $3->type==tbyte)
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
			$$->type=tbyte;
		}
		else if($3->type==tlong && ($1->type==tlong || $1->type==tint || $1->type==tbyte || $1->type==tshort || $1->type==tchar))
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
			$$->type=tlong;
		}
                else if($3->type==tint && ($1->type==tint || $1->type==tbyte || $1->type==tshort || $1->type==tchar))
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
			$$->type=tint;
		}
                else if($3->type==tshort && ($1->type==tbyte || $1->type==tshort))
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
			$$->type=tshort;
		}
                else if($3->type==tbyte && $1->type==tbyte )
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
			$$->type=tbyte;
		}
                else if($3->type==tchar && $1->type==tchar)
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
			$$->type=tchar;
		}
                else
                {
                        printf("ERROR:Incorrect usage of shift operator on line %d\n",yylineno);
                	$$->type=tnone;
		}
	}
	|
	AddExpression	{$$=$1;}
	|
	ShiftExpression ShiftOperator error SEMICOLON	{$$=(struct attribute *)malloc(sizeof(struct attribute));$$->type=tnone;printf("Error in expression at line %d\n",yylineno);}
;
RelExpression:
	RelExpression RelOperator ShiftExpression	
	{	$$=(struct attribute *)malloc(sizeof(struct attribute));
		$$->token=1;
		$$->dimension=0;

		
		char *val1=Address($1->contains);
		char *val2=Address($3->contains);
		char *temp;
		if($1->contains[0]=='_' && $1->contains[1]=='T')
			temp=val1;
		else if($3->contains[0]=='_' && $3->contains[1]=='T')
			temp=val2;
		else
		{	
			temp=getNewTemp();
			int off=(temp[2]-'0')*10+temp[3]-'0';
			offset_temp[off]=-num_var*4;
			num_var++;
		}
		strcpy($$->contains,temp);
		char *val3=Address(temp);
		enum refType t1=Ref(val1);
		enum refType t2=Ref(val2);
	
		if($1->type==tdouble && $3->type!=tstring && $3->type!=tboolean && $3->type!=tnull && $3->type!=tvoid && $3->type!=tnone)
		{
			if(t1==constant)
				fprintf(fcg,"li.s $f0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"l.s $f0,%s\n",val1);
			else
				fprintf(fcg,"mov.s $f0,%s\n",val1);
			if($3->type!=tdouble && $3->type!=tfloat)
			{
				if(t2==constant)
					fprintf(fcg,"li $t0,%s\n",val2);
				else if(t2==memory)
					fprintf(fcg,"lw $t0,%s\n",val2);
				else
					fprintf(fcg,"move $t0,%s\n",val2);
				fprintf(fcg,"mtc1 $t0,$f1\n");
				fprintf(fcg,"cvt.s.w $f1,$f1\n");
			}
			else
			{
				if(t2==constant)
					fprintf(fcg,"li.s $f1,%s\n",val2);
				else if(t2==memory)
					fprintf(fcg,"l.s $f1,%s\n",val2);
				else
					fprintf(fcg,"mov.s $f1,%s\n",val2);
			}
			char *t=(char *)malloc(10);
			strcpy(t,$2);
			t[0]='u';
			if(t[1]=='g')
			{
				t[1]='l';
				fprintf(fcg,"c.%s.s $f0,$f1\n",t);
				fprintf(fcg,"bc1f true%d\n",te++);
				fprintf(fcg,"li $t0,0\n");
				fprintf(fcg,"b done%d\n",te++);
				fprintf(fcg,"true%d:\n",te-2);
				fprintf(fcg,"li $t0,1\n");
				fprintf(fcg,"done%d:\n",te-1);
				fprintf(fcg,"sw $t0,%s\n",val3);
			}
			else
			{
				fprintf(fcg,"c.%s.s $f0,$f1\n",t);
				fprintf(fcg,"bc1t true%d\n",te++);
				fprintf(fcg,"li $t0,0\n");
				fprintf(fcg,"b done%d\n",te++);
				fprintf(fcg,"true%d:\n",te-2);
				fprintf(fcg,"li $t0,1\n");
				fprintf(fcg,"done%d:\n",te-1);
				fprintf(fcg,"sw $t0,%s\n",val3);
			}
			$$->type=tboolean;
		}
		else if($1->type==tfloat && $3->type!=tdouble \
		&& $3->type!=tstring && $3->type!=tboolean && $3->type!=tnull && $3->type!=tvoid && $3->type!=tnone)
		{
			if(t1==constant)
				fprintf(fcg,"li.s $f0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"l.s $f0,%s\n",val1);
			else
				fprintf(fcg,"mov.s $f0,%s\n",val1);
			if($3->type!=tdouble && $3->type!=tfloat)
			{
				if(t2==constant)
					fprintf(fcg,"li $t0,%s\n",val2);
				else if(t2==memory)
					fprintf(fcg,"lw $t0,%s\n",val2);
				else
					fprintf(fcg,"move $t0,%s\n",val2);
				fprintf(fcg,"mtc1 $t0,$f1\n");
				fprintf(fcg,"cvt.s.w $f1,$f1\n");
			}
			else
			{
				if(t2==constant)
					fprintf(fcg,"li.s $f1,%s\n",val2);
				else if(t2==memory)
					fprintf(fcg,"l.s $f1,%s\n",val2);
				else
					fprintf(fcg,"mov.s $f1,%s\n",val2);
			}
			char *t=(char *)malloc(10);
			strcpy(t,$2);
			t[0]='u';
			if(t[1]=='g')
			{
				t[1]='l';
				fprintf(fcg,"c.%s.s $f0,$f1\n",t);
				fprintf(fcg,"bc1f true%d\n",te++);
				fprintf(fcg,"li $t0,0\n");
				fprintf(fcg,"b done%d\n",te++);
				fprintf(fcg,"true%d:\n",te-2);
				fprintf(fcg,"li $t0,1\n");
				fprintf(fcg,"done%d:\n",te-1);
				fprintf(fcg,"sw $t0,%s\n",val3);
			}
			else
			{
				fprintf(fcg,"c.%s.s $f0,$f1\n",t);
				fprintf(fcg,"bc1t true%d\n",te++);
				fprintf(fcg,"li $t0,0\n");
				fprintf(fcg,"b done%d\n",te++);
				fprintf(fcg,"true%d:\n",te-2);
				fprintf(fcg,"li $t0,1\n");
				fprintf(fcg,"done%d:\n",te-1);
				fprintf(fcg,"sw $t0,%s\n",val3);
			}
			$$->type=tboolean;			
		}
		else if($1->type==tlong && ($3->type==tlong || $3->type==tint || $3->type==tbyte || $3->type==tshort || $3->type==tchar))
		{
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
                        $$->type=tboolean;
		}
                else if($1->type==tint && ($3->type==tint || $3->type==tbyte || $3->type==tshort || $3->type==tchar))
		{
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
                        $$->type=tboolean;
		}
                else if($1->type==tshort && ($3->type==tbyte || $3->type==tshort))
		{
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
                        $$->type=tboolean;
		}
                else if($1->type==tbyte && $3->type==tbyte )
		{
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
                        $$->type=tboolean;
		}
                else if($1->type==tchar && $3->type==tchar)
		{
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lb $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lb $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
                        $$->type=tboolean;
		}	
		else if($3->type==tdouble && $1->type!=tstring && $1->type!=tboolean && $1->type!=tnull && $1->type!=tvoid && $1->type!=tnone)
		{
			if(t2==constant)
				fprintf(fcg,"li.s $f0,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"l.s $f0,%s\n",val2);
			else
				fprintf(fcg,"mov.s $f0,%s\n",val2);
			if($1->type!=tdouble && $1->type!=tfloat)
			{
				if(t1==constant)
					fprintf(fcg,"li $t0,%s\n",val1);
				else if(t1==memory)
					fprintf(fcg,"lw $t0,%s\n",val1);
				else
					fprintf(fcg,"move $t0,%s\n",val1);
				fprintf(fcg,"mtc1 $t0,$f1\n");
				fprintf(fcg,"cvt.s.w $f1,$f1\n");
			}
			else
			{
				if(t1==constant)
					fprintf(fcg,"li.s $f1,%s\n",val1);
				else if(t1==memory)
					fprintf(fcg,"l.s $f1,%s\n",val1);
				else
					fprintf(fcg,"mov.s $f1,%s\n",val1);
			}
			char *t=(char *)malloc(10);
			strcpy(t,$2);
			t[0]='u';
			if(t[1]=='g')
			{
				t[1]='l';
				fprintf(fcg,"c.%s.s $f0,$f1\n",t);
				fprintf(fcg,"bc1f true%d\n",te++);
				fprintf(fcg,"li $t0,0\n");
				fprintf(fcg,"b done%d\n",te++);
				fprintf(fcg,"true%d:\n",te-2);
				fprintf(fcg,"li $t0,1\n");
				fprintf(fcg,"done%d:\n",te-1);
				fprintf(fcg,"sw $t0,%s\n",val3);
			}
			else
			{
				fprintf(fcg,"c.%s.s $f0,$f1\n",t);
				fprintf(fcg,"bc1t true%d\n",te++);
				fprintf(fcg,"li $t0,0\n");
				fprintf(fcg,"b done%d\n",te++);
				fprintf(fcg,"true%d:\n",te-2);
				fprintf(fcg,"li $t0,1\n");
				fprintf(fcg,"done%d:\n",te-1);
				fprintf(fcg,"sw $t0,%s\n",val3);
			}
			$$->type=tboolean;
		}
		else if($3->type==tfloat && $1->type!=tdouble && $1->type!=tstring && $1->type!=tboolean \
		&& $1->type!=tnull && $1->type!=tvoid && $1->type!=tnone) 
		{
			if(t2==constant)
				fprintf(fcg,"li.s $f0,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"l.s $f0,%s\n",val2);
			else
				fprintf(fcg,"mov.s $f0,%s\n",val2);
			if($1->type!=tdouble && $1->type!=tfloat)
			{
				if(t1==constant)
					fprintf(fcg,"li $t0,%s\n",val1);
				else if(t1==memory)
					fprintf(fcg,"lw $t0,%s\n",val1);
				else
					fprintf(fcg,"move $t0,%s\n",val1);
				fprintf(fcg,"mtc1 $t0,$f1\n");
				fprintf(fcg,"cvt.s.w $f1,$f1\n");
			}
			else
			{
				if(t1==constant)
					fprintf(fcg,"li.s $f1,%s\n",val1);
				else if(t1==memory)
					fprintf(fcg,"l.s $f1,%s\n",val1);
				else
					fprintf(fcg,"mov.s $f1,%s\n",val1);
			}
			char *t=(char *)malloc(10);
			strcpy(t,$2);
			t[0]='u';
			if(t[1]=='g')
			{
				t[1]='l';
				fprintf(fcg,"c.%s.s $f0,$f1\n",t);
				fprintf(fcg,"bc1f true%d\n",te++);
				fprintf(fcg,"li $t0,0\n");
				fprintf(fcg,"b done%d\n",te++);
				fprintf(fcg,"true%d:\n",te-2);
				fprintf(fcg,"li $t0,1\n");
				fprintf(fcg,"done%d:\n",te-1);
				fprintf(fcg,"sw $t0,%s\n",val3);
			}
			else
			{
				fprintf(fcg,"c.%s.s $f0,$f1\n",t);
				fprintf(fcg,"bc1t true%d\n",te++);
				fprintf(fcg,"li $t0,0\n");
				fprintf(fcg,"b done%d\n",te++);
				fprintf(fcg,"true%d:\n",te-2);
				fprintf(fcg,"li $t0,1\n");
				fprintf(fcg,"done%d:\n",te-1);
				fprintf(fcg,"sw $t0,%s\n",val3);
			}
			$$->type=tboolean;
		}
		else if($3->type==tlong && ($1->type==tlong || $1->type==tint || $1->type==tbyte || $1->type==tshort || $1->type==tchar))
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
                        $$->type=tboolean;
		}
                else if($3->type==tint && ($1->type==tint || $1->type==tbyte || $1->type==tshort || $1->type==tchar))
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
                        $$->type=tboolean;
		}
                else if($3->type==tshort && ($1->type==tbyte || $1->type==tshort))
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
                        $$->type=tboolean;
		}
                else if($3->type==tbyte && $1->type==tbyte)
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
                        $$->type=tboolean;
		}
                else if($3->type==tchar && $1->type==tchar)
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lb $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lb $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
                        $$->type=tboolean;
		}
                else
                {
                        printf("ERROR:Incorrect usage of relop on line %d\n",yylineno);
                        $$->type=tnone;
                }
		
	}
	|	
	ShiftExpression		{$$=$1;}
	|
	RelExpression RelOperator error SEMICOLON	{$$=(struct attribute *)malloc(sizeof(struct attribute));$$->type=tnone;printf("Error in expression at line %d\n",yylineno);}
;
CompExpression://add floating point type
	CompExpression CompOperator RelExpression	
	{	$$=(struct attribute *)malloc(sizeof(struct attribute));
		$$->token=1;
		$$->dimension=0;

		
		char *val1=Address($1->contains);
		char *val2=Address($3->contains);
		char *temp;
		if($1->contains[0]=='_' && $1->contains[1]=='T')
			temp=val1;
		else if($3->contains[0]=='_' && $3->contains[1]=='T')
			temp=val2;
		else
		{	
			temp=getNewTemp();
			int off=(temp[2]-'0')*10+temp[3]-'0';
			offset_temp[off]=-num_var*4;
			num_var++;
		}
		strcpy($$->contains,temp);
		char *val3=Address(temp);
		enum refType t1=Ref(val1);
		enum refType t2=Ref(val2);
	
		if($1->type==tdouble && $3->type!=tstring && $3->type!=tboolean && $3->type!=tnull && $3->type!=tvoid && $3->type!=tnone)
		{
			if(t1==constant)
				fprintf(fcg,"li.s $f0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"l.s $f0,%s\n",val1);
			else
				fprintf(fcg,"mov.s $f0,%s\n",val1);
			if($3->type!=tdouble && $3->type!=tfloat)
			{
				if(t2==constant)
					fprintf(fcg,"li $t0,%s\n",val2);
				else if(t2==memory)
					fprintf(fcg,"lw $t0,%s\n",val2);
				else
					fprintf(fcg,"move $t0,%s\n",val2);
				fprintf(fcg,"mtc1 $t0,$f1\n");
				fprintf(fcg,"cvt.s.w $f1,$f1\n");
			}
			else
			{
				if(t2==constant)
					fprintf(fcg,"li.s $f1,%s\n",val2);
				else if(t2==memory)
					fprintf(fcg,"l.s $f1,%s\n",val2);
				else
					fprintf(fcg,"mov.s $f1,%s\n",val2);
			}
			fprintf(fcg,"c.seq.s $f0,$f1\n");
			if(!strcmp($2,"seq"))
				fprintf(fcg,"bc1t true%d\n",te++);
			else
				fprintf(fcg,"bc1f true%d\n",te++);
			fprintf(fcg,"li $t0,0\n");
			fprintf(fcg,"b done%d\n",te++);
			fprintf(fcg,"true%d:\n",te-2);
			fprintf(fcg,"li $t0,1\n");
			fprintf(fcg,"done%d:\n",te-1);
			fprintf(fcg,"sw $t0,%s\n",val3);
			$$->type=tboolean;
		}
		else if($1->type==tfloat && $3->type!=tdouble \
		&& $3->type!=tstring && $3->type!=tboolean && $3->type!=tnull && $3->type!=tvoid && $3->type!=tnone)
		{
			if(t1==constant)
				fprintf(fcg,"li.s $f0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"l.s $f0,%s\n",val1);
			else
				fprintf(fcg,"mov.s $f0,%s\n",val1);
			if($3->type!=tdouble && $3->type!=tfloat)
			{
				if(t2==constant)
					fprintf(fcg,"li $t0,%s\n",val2);
				else if(t2==memory)
					fprintf(fcg,"lw $t0,%s\n",val2);
				else
					fprintf(fcg,"move $t0,%s\n",val2);
				fprintf(fcg,"mtc1 $t0,$f1\n");
				fprintf(fcg,"cvt.s.w $f1,$f1\n");
			}
			else
			{
				if(t2==constant)
					fprintf(fcg,"li.s $f1,%s\n",val2);
				else if(t2==memory)
					fprintf(fcg,"l.s $f1,%s\n",val2);
				else
					fprintf(fcg,"mov.s $f1,%s\n",val2);
			}
			fprintf(fcg,"c.%s.s $f0,$f1\n",$2);
			fprintf(fcg,"bc1t true%d\n",te++);
			fprintf(fcg,"li $t0,0\n");
			fprintf(fcg,"b done%d\n",te++);
			fprintf(fcg,"true%d:\n",te-2);
			fprintf(fcg,"li $t0,1\n");
			fprintf(fcg,"done%d:\n",te-1);
			fprintf(fcg,"sw $t0,%s\n",val3);
			$$->type=tboolean;			
		}
		else if($1->type==tlong && ($3->type==tlong || $3->type==tint || $3->type==tbyte || $3->type==tshort || $3->type==tchar))
		{
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
                        $$->type=tboolean;
		}
                else if($1->type==tint && ($3->type==tint || $3->type==tbyte || $3->type==tshort || $3->type==tchar))
		{
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
                        $$->type=tboolean;
		}
                else if($1->type==tshort && ($3->type==tbyte || $3->type==tshort))
		{
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
                        $$->type=tboolean;
		}
                else if($1->type==tbyte && $3->type==tbyte )
		{
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
                        $$->type=tboolean;
		}
                else if($1->type==tchar && $3->type==tchar)
		{
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lb $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lb $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
                        $$->type=tboolean;
		}	
		else if($3->type==tdouble && $1->type!=tstring && $1->type!=tboolean && $1->type!=tnull && $1->type!=tvoid && $1->type!=tnone)
		{
			if(t2==constant)
				fprintf(fcg,"li.s $f0,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"l.s $f0,%s\n",val2);
			else
				fprintf(fcg,"mov.s $f0,%s\n",val2);
			if($1->type!=tdouble && $1->type!=tfloat)
			{
				if(t1==constant)
					fprintf(fcg,"li $t0,%s\n",val1);
				else if(t1==memory)
					fprintf(fcg,"lw $t0,%s\n",val1);
				else
					fprintf(fcg,"move $t0,%s\n",val1);
				fprintf(fcg,"mtc1 $t0,$f1\n");
				fprintf(fcg,"cvt.s.w $f1,$f1\n");
			}
			else
			{
				if(t1==constant)
					fprintf(fcg,"li.s $f1,%s\n",val1);
				else if(t1==memory)
					fprintf(fcg,"l.s $f1,%s\n",val1);
				else
					fprintf(fcg,"mov.s $f1,%s\n",val1);
			}
			fprintf(fcg,"%s $f1,$f0,$f1\n",$2);
			fprintf(fcg,"s.s $f1,%s\n",val3);
			$$->type=tboolean;
		}
		else if($3->type==tfloat && $1->type!=tdouble && $1->type!=tstring && $1->type!=tboolean \
		&& $1->type!=tnull && $1->type!=tvoid && $1->type!=tnone) 
		{
			if(t2==constant)
				fprintf(fcg,"li.s $f0,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"l.s $f0,%s\n",val2);
			else
				fprintf(fcg,"mov.s $f0,%s\n",val2);
			if($1->type!=tdouble && $1->type!=tfloat)
			{
				if(t1==constant)
					fprintf(fcg,"li $t0,%s\n",val1);
				else if(t1==memory)
					fprintf(fcg,"lw $t0,%s\n",val1);
				else
					fprintf(fcg,"move $t0,%s\n",val1);
				fprintf(fcg,"mtc1 $t0,$f1\n");
				fprintf(fcg,"cvt.s.w $f1,$f1\n");
			}
			else
			{
				if(t1==constant)
					fprintf(fcg,"li.s $f1,%s\n",val1);
				else if(t1==memory)
					fprintf(fcg,"l.s $f1,%s\n",val1);
				else
					fprintf(fcg,"mov.s $f1,%s\n",val1);
			}
			fprintf(fcg,"%s $f1,$f0,$f1\n",$2);
			fprintf(fcg,"s.s $f1,%s\n",val3);
			$$->type=tboolean;
		}
		else if($3->type==tlong && ($1->type==tlong || $1->type==tint || $1->type==tbyte || $1->type==tshort || $1->type==tchar))
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"lw $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
                        $$->type=tboolean;
		}
                else if($3->type==tint && ($1->type==tint || $1->type==tbyte || $1->type==tshort || $1->type==tchar))
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
                        $$->type=tboolean;
		}
                else if($3->type==tshort && ($1->type==tbyte || $1->type==tshort))
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
                        $$->type=tboolean;
		}
                else if($3->type==tbyte && $1->type==tbyte)
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
                        $$->type=tboolean;
		}
                else if($3->type==tchar && $1->type==tchar)
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lb $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lb $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"%s $t0,$t0,$t1\n",$2);
			fprintf(fcg,"sw $t0,%s\n",val3);
                        $$->type=tboolean;
		}
		else if($1->ref!=NULL && $3->ref!=NULL && !strcmp($1->ref,$3->ref))
		{
			strcpy($$->ref,$1->ref);
			$$->token=2;
		}
                else
                {
                        printf("ERROR:Incorrect usage of == on line %d\n",yylineno);
                        $$->type=tnone;
                }
		
	}
	|
	RelExpression	{$$=$1;}
	|
	CompExpression CompOperator error SEMICOLON	{$$->type=tnone;printf("ERROR:Error in expression at line %d\n",yylineno);}
;
BitAndExpression:
	BitAndExpression BAND CompExpression	
	{	
		$$=(struct attribute *)malloc(sizeof(struct attribute));
		$$->token=1;
		$$->dimension=0;
		
		char *val1=Address($1->contains);
		char *val2=Address($3->contains);
		char *temp;
		if($1->contains[0]=='_' && $1->contains[1]=='T')
			temp=val1;
		else if($3->contains[0]=='_' && $3->contains[1]=='T')
			temp=val2;
		else
		{	
			temp=getNewTemp();
			int off=(temp[2]-'0')*10+temp[3]-'0';
			offset_temp[off]=-num_var*4;
			num_var++;
		}
		strcpy($$->contains,temp);
		char *val3=Address(temp);
		enum refType t1=Ref(val1);
		enum refType t2=Ref(val2);
		if($1->type==tlong && ($3->type==tlong || $3->type==tint || $3->type==tbyte || $3->type==tshort))
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"and $t0,$t0,$t1\n");
			fprintf(fcg,"sw $t0,%s\n",val3);
			$$->type=tlong;
		}				
                else if($1->type==tint && ($3->type==tint || $3->type==tbyte || $3->type==tshort))
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"and $t0,$t0,$t1\n");
			fprintf(fcg,"sw $t0,%s\n",val3);
			$$->type=tint;
		}
                else if($1->type==tshort && ($3->type==tbyte || $3->type==tshort))
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"and $t0,$t0,$t1\n");
			fprintf(fcg,"sw $t0,%s\n",val3);
			$$->type=tshort;
		}
                else if($1->type==tbyte && $3->type==tbyte)
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"and $t0,$t0,$t1\n");
			fprintf(fcg,"sw $t0,%s\n",val3);
			$$->type=tbyte;
		}
		else if($3->type==tlong && ($1->type==tlong || $1->type==tint || $1->type==tbyte || $1->type==tshort || $1->type==tchar))
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"and $t0,$t0,$t1\n");
			fprintf(fcg,"sw $t0,%s\n",val3);
			$$->type=tlong;
		}
                else if($3->type==tint && ($1->type==tint || $1->type==tbyte || $1->type==tshort || $1->type==tchar))
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"lw $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"and $t0,$t0,$t1\n");
			fprintf(fcg,"sw $t0,%s\n",val3);
			$$->type=tint;
		}
                else if($3->type==tshort && ($1->type==tbyte || $1->type==tshort))
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"and $t0,$t0,$t1\n");
			fprintf(fcg,"sw $t0,%s\n",val3);
			$$->type=tshort;
		}
                else if($3->type==tbyte && $1->type==tbyte )
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"and $t0,$t0,$t1\n");
			fprintf(fcg,"sw $t0,%s\n",val3);
			$$->type=tbyte;
		}
                else if($3->type==tchar && $1->type==tchar)
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lb $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lb $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"and $t0,$t0,$t1\n");
			fprintf(fcg,"sw $t0,%s\n",val3);
			$$->type=tchar;
		}
                else
                {
                        printf("ERROR:Incorrect usage of & on line %d\n",yylineno);
			$$->type=tnone;
               	}
	}
	|
	CompExpression	{$$=$1;}
	|
	BitAndExpression BAND error SEMICOLON	{$$=(struct attribute *)malloc(sizeof(struct attribute));$$->type=tnone;printf("ERROR:Error in expression at line %d\n",yylineno);}
;
XORExpression:
	XORExpression XOR BitAndExpression	
	{	
		$$=(struct attribute *)malloc(sizeof(struct attribute));
		$$->token=1;
		$$->dimension=0;
		
		char *val1=Address($1->contains);
		char *val2=Address($3->contains);
		char *temp;
		if($1->contains[0]=='_' && $1->contains[1]=='T')
			temp=val1;
		else if($3->contains[0]=='_' && $3->contains[1]=='T')
			temp=val2;
		else
		{	
			temp=getNewTemp();
			int off=(temp[2]-'0')*10+temp[3]-'0';
			offset_temp[off]=-num_var*4;
			num_var++;
		}
		strcpy($$->contains,temp);
		char *val3=Address(temp);
		enum refType t1=Ref(val1);
		enum refType t2=Ref(val2);
		
		if($1->type==tlong && ($3->type==tlong || $3->type==tint || $3->type==tbyte || $3->type==tshort))
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"xor $t0,$t0,$t1\n");
			fprintf(fcg,"sw $t0,%s\n",val3);
			$$->type=tlong;
		}				
                else if($1->type==tint && ($3->type==tint || $3->type==tbyte || $3->type==tshort))
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"xor $t0,$t0,$t1\n");
			fprintf(fcg,"sw $t0,%s\n",val3);
			$$->type=tint;
		}
                else if($1->type==tshort && ($3->type==tbyte || $3->type==tshort))
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"xor $t0,$t0,$t1\n");
			fprintf(fcg,"sw $t0,%s\n",val3);
			$$->type=tshort;
		}
                else if($1->type==tbyte && $3->type==tbyte)
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"xor $t0,$t0,$t1\n");
			fprintf(fcg,"sw $t0,%s\n",val3);
			$$->type=tbyte;
		}
		else if($3->type==tlong && ($1->type==tlong || $1->type==tint || $1->type==tbyte || $1->type==tshort || $1->type==tchar))
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"xor $t0,$t0,$t1\n");
			fprintf(fcg,"sw $t0,%s\n",val3);
			$$->type=tlong;
		}
                else if($3->type==tint && ($1->type==tint || $1->type==tbyte || $1->type==tshort || $1->type==tchar))
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"xor $t0,$t0,$t1\n");
			fprintf(fcg,"sw $t0,%s\n",val3);
			$$->type=tint;
		}
                else if($3->type==tshort && ($1->type==tbyte || $1->type==tshort))
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"xor $t0,$t0,$t1\n");
			fprintf(fcg,"sw $t0,%s\n",val3);
			$$->type=tshort;
		}
                else if($3->type==tbyte && $1->type==tbyte )
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"xor $t0,$t0,$t1\n");
			fprintf(fcg,"sw $t0,%s\n",val3);
			$$->type=tbyte;
		}
                else if($3->type==tchar && $1->type==tchar)
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lb $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lb $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"xor $t0,$t0,$t1\n");
			fprintf(fcg,"sw $t0,%s\n",val3);
			$$->type=tchar;
		}
                else
                {
                        printf("ERROR:Incorrect usage of ^ on line %d\n",yylineno);
                        $$->type=tnone;
                }
	}
	|
	BitAndExpression	{$$=$1;}
	|
	XORExpression XOR error SEMICOLON	{$$=(struct attribute *)malloc(sizeof(struct attribute));$$->type=tnone;printf("ERROR:Error in expression at line %d\n",yylineno);}
;
BORExpression:
	BORExpression BOR XORExpression	
	{
		$$=(struct attribute *)malloc(sizeof(struct attribute));
		$$->token=1;
		$$->dimension=0;
		
		char *val1=Address($1->contains);
		char *val2=Address($3->contains);
		char *temp;
		if($1->contains[0]=='_' && $1->contains[1]=='T')
			temp=val1;
		else if($3->contains[0]=='_' && $3->contains[1]=='T')
			temp=val2;
		else
		{	
			temp=getNewTemp();
			int off=(temp[2]-'0')*10+temp[3]-'0';
			offset_temp[off]=-num_var*4;
			num_var++;
		}
		strcpy($$->contains,temp);
		char *val3=Address(temp);
		enum refType t1=Ref(val1);
		enum refType t2=Ref(val2);
		
		if($1->type==tlong && ($3->type==tlong || $3->type==tint || $3->type==tbyte || $3->type==tshort))
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"or $t0,$t0,$t1\n");
			fprintf(fcg,"sw $t0,%s\n",val3);
			$$->type=tlong;
		}				
                else if($1->type==tint && ($3->type==tint || $3->type==tbyte || $3->type==tshort))
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"or $t0,$t0,$t1\n");
			fprintf(fcg,"sw $t0,%s\n",val3);
			$$->type=tint;
		}
                else if($1->type==tshort && ($3->type==tbyte || $3->type==tshort))
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"or $t0,$t0,$t1\n");
			fprintf(fcg,"sw $t0,%s\n",val3);
			$$->type=tshort;
		}
                else if($1->type==tbyte && $3->type==tbyte)
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"or $t0,$t0,$t1\n");
			fprintf(fcg,"sw $t0,%s\n",val3);
			$$->type=tbyte;
		}
		else if($3->type==tlong && ($1->type==tlong || $1->type==tint || $1->type==tbyte || $1->type==tshort || $1->type==tchar))
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"or $t0,$t0,$t1\n");
			fprintf(fcg,"sw $t0,%s\n",val3);
			$$->type=tlong;
		}
                else if($3->type==tint && ($1->type==tint || $1->type==tbyte || $1->type==tshort || $1->type==tchar))
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"or $t0,$t0,$t1\n");
			fprintf(fcg,"sw $t0,%s\n",val3);
			$$->type=tint;
		}
                else if($3->type==tshort && ($1->type==tbyte || $1->type==tshort))
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"or $t0,$t0,$t1\n");
			fprintf(fcg,"sw $t0,%s\n",val3);
			$$->type=tshort;
		}
                else if($3->type==tbyte && $1->type==tbyte )
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"or $t0,$t0,$t1\n");
			fprintf(fcg,"sw $t0,%s\n",val3);
			$$->type=tbyte;
		}
                else if($3->type==tchar && $1->type==tchar)
                {
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lb $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lb $t1,%s\n",val2);
			fprintf(fcg,"or $t0,$t0,$t1\n");
			fprintf(fcg,"sw $t0,%s\n",val3);
			$$->type=tchar;
		}	
                else
                {
                        printf("ERROR:Incorrect usage of | on line %d\n",yylineno);
                        $$->type=tnone;
                }
	}
	|
	XORExpression	{$$=$1;}
	|
	BORExpression BOR error SEMICOLON	{$$=(struct attribute *)malloc(sizeof(struct attribute));$$->type=tnone;printf("ERROR:Error in expression at line %d\n",yylineno);}
;
ANDExpression:
	ANDExpression AND 
	{
		char *val1=Address($1->contains);
		enum refType t1=Ref(val1);
		if($1->type==tboolean)
		{
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			labels.push(num_label++);
			fprintf(fcg,"beqz $t0,L%d\n",labels.top());
		}
		else
			printf("ERROR:incorrect usage of && operator at line %d\n",yylineno);
	}
	BORExpression		
	{	$$=(struct attribute *)malloc(sizeof(struct attribute));
		$$->token=1;
		$$->dimension=0;
		char *temp=getNewTemp();
		
		int i;
		for(i=0;i<strlen(temp);i++)
			$$->contains[i]=temp[i];
		$$->contains[i]='\0';

		int off=(temp[2]-'0')*10+temp[3]-'0';
		offset_temp[off]=-num_var*4;
		num_var++;
		char *val2=Address($4->contains);
		char *val3=Address(temp);
		enum refType t2=Ref(val2);
                if($1->type==tboolean && $4->type==tboolean)
                {
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"and $t0,$t0,$t1\n");
			fprintf(fcg,"L%d:\n",labels.top());
			labels.pop();
			fprintf(fcg,"sw $t0,%s\n",val3);
			$$->type=tboolean;
		}
                else
                {
                        printf("ERROR:Incorrect usage of && on line %d\n",yylineno);
                        $$->type=tnone;
                }
	}
	|
	BORExpression	{$$=$1;}
	|
	ANDExpression AND error SEMICOLON	{$$=(struct attribute *)malloc(sizeof(struct attribute));$$->type=tnone;printf("ERROR:Error in expression at line %d\n",yylineno);}
;
ORExpression:
	ORExpression OR 	
	{	
		char *val1=Address($1->contains);
		enum refType t1=Ref(val1);
		if($1->type==tboolean)
		{
			if(t1==constant)
				fprintf(fcg,"li $t0,%s\n",val1);
			else if(t1==memory)
				fprintf(fcg,"lw $t0,%s\n",val1);
			else
				fprintf(fcg,"move $t0,%s\n",val1);
			labels.push(num_label++);
			fprintf(fcg,"bnez $t0,L%d\n",labels.top());
		}
		else
			printf("ERROR:incorrect usage of || operator at line %d\n",yylineno);
	}
	ANDExpression		
	{	$$=(struct attribute *)malloc(sizeof(struct attribute));
		$$->token=1;
		$$->dimension=0;

		char *temp=getNewTemp();

		int i;
		for(i=0;i<strlen(temp);i++)
			$$->contains[i]=temp[i];
		$$->contains[i]='\0';

		int off=(temp[2]-'0')*10+temp[3]-'0';
		offset_temp[off]=-num_var*4;
		num_var++;
		char *val2=Address($4->contains);
		char *val3=Address(temp);
		enum refType t2=Ref(val2);
                if($1->type==tboolean && $4->type==tboolean)
                {
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
			fprintf(fcg,"and $t0,$t0,$t1\n");
			fprintf(fcg,"L%d:\n",labels.top());
			labels.pop();
			fprintf(fcg,"sw $t0,%s\n",val3);
			$$->type=tboolean;
		}
                else
                {
                        printf("ERROR:Incorrect usage of && on line %d\n",yylineno);
                        $$->type=tnone;
                }
	}
	|
	ANDExpression	{$$=$1;}
	|
	ORExpression OR error SEMICOLON	{$$=(struct attribute *)malloc(sizeof(struct attribute));$$->type=tnone;printf("ERROR:Error in expression at line %d\n",yylineno);}
;
TernaryExpression:
	ORExpression				{$$=$1;}
	|
	ORExpression TERNARY
	{
		 char *val1=Address($1->contains);
		 enum refType t1=Ref(val1);
		 if(t1==constant)
			fprintf(fcg,"li $t0,%s\n",val1);
		else if(t1==memory)
			fprintf(fcg,"lw $t0,%s\n",val1);
		else
			fprintf(fcg,"move $t0,%s\n",val1);
		labels.push(num_label++);
		fprintf(fcg,"beqz $t0,L%d\n",labels.top());
	}
	Expression 
	{
		char *val2=Address($4->contains);
		enum refType t2=Ref(val2);
		if($4->type==tfloat || $4->type==tdouble)
		{
			if(t2==constant)
				fprintf(fcg,"li.s $f1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"l.s $f1,%s\n",val2);
			else
				fprintf(fcg,"mov.s $f1,%s\n",val2);
		}
		else
		{							
			if(t2==constant)
				fprintf(fcg,"li $t1,%s\n",val2);
			else if(t2==memory)
				fprintf(fcg,"lw $t1,%s\n",val2);
			else
				fprintf(fcg,"move $t1,%s\n",val2);
		}
		int val=labels.top();
		labels.pop();
		labels.push(num_label++);
		fprintf(fcg,"b L%d\n",labels.top());
		fprintf(fcg,"L%d:\n",val);
	}COLON TernaryExpression 
	{	$$=(struct attribute *)malloc(sizeof(struct attribute));
		$$->token=1;
		$$->dimension=0;
		char *temp=getNewTemp();

		int i;
		for(i=0;i<strlen(temp);i++)
			$$->contains[i]=temp[i];
		$$->contains[i]='\0';

		int off=(temp[2]-'0')*10+temp[3]-'0';
		offset_temp[off]=-num_var*4;
		num_var++;
		char *val3=Address($7->contains);
		enum refType t3=Ref(val3);
		if($1->type==tboolean)
		{
			if($4->type!=tnone && $7->type!=tnone)
			{
				if(($4->type==tboolean && $7->type!=tboolean) || ($7->type==tboolean && $4->type!=tboolean))
				{
					$$->type=tnone;
					printf("ERROR:erroneous comparison at line %d\n",yylineno);
				}
				else
				{
					if($7->type==tfloat || $7->type==tdouble)
					{
						if(t3==constant)
							fprintf(fcg,"li.s $f2,%s\n",val3);
						else if(t3==memory)
							fprintf(fcg,"l.s $f2,%s\n",val3);
						else
							fprintf(fcg,"mov.s $f2,%s\n",val3);
					}
					else
					{							
						if(t3==constant)
							fprintf(fcg,"li $t2,%s\n",val3);
						else if(t3==memory)
							fprintf(fcg,"lw $t2,%s\n",val3);
						else
							fprintf(fcg,"move $t2,%s\n",val3);
					}
					if($7->type==tdouble || $7->type==tfloat)
						fprintf(fcg,"s.s $f2,%s\n",Address(temp));
					else
						fprintf(fcg,"sw $t2,%s\n",Address(temp));
					fprintf(fcg,"b L%d\n",num_label++);
					fprintf(fcg,"L%d:\n",labels.top());
					if($4->type==tdouble || $4->type==tfloat)
						fprintf(fcg,"s.s $f1,%s\n",Address(temp));
					else
						fprintf(fcg,"sw $t1,%s\n",Address(temp));
					labels.pop();
					fprintf(fcg,"L%d:\n",num_label-1);
					if($4->type==tdouble || $7->type==tdouble)
						$$->type=tdouble;
					else if($4->type==tfloat || $7->type==tfloat)
						$$->type=tfloat;
					else
						$$->type=$7->type;
				}
			}
			else
			{
				printf("ERROR:Type mismatch at line %d\n",yylineno);
				$$->type=tnone;
			}
		}
		else
			$$->type=tnone;
	}
	|
	ORExpression TERNARY error SEMICOLON { $$=(struct attribute *)malloc(sizeof(struct attribute));$$->type=tnone;printf("ERROR:Error in ternary expression on line %d\n",yylineno);}
; 
Expression:
	TernaryExpression	{$$=$1;}			
	|
	Assignment		{$$=$1;}
;
Assignment:
	LeftHandSide AssignmentOperator Expression	
	{  
	   	$$=(struct attribute *)malloc(sizeof(struct attribute));
		char *val1=Address($1->contains);
		char *val2=Address($3->contains);
		//printf("%s %s %d %d\n",val1,val2,$1->token,$3->token);
		enum refType t1=Ref(val1);
		enum refType t2=Ref(val2);
		jump_found=false;
	   	if(($1->token==1 && $3->token==1) || ($1->token==3 && $3->token==3))
	   	{
			if($1->type==tdouble && $3->type!=tstring && $3->type!=tnull && $3->type!=tnone && $3->type!=tvoid && $3->type!=tboolean)
			{
				if($3->token==1)
				{
					if($3->type==tdouble || $3->type==tfloat)
					{
						if(t2==constant)
							fprintf(fcg,"li.s $f0,%s\n",val2);
						else if(t2==memory)
							fprintf(fcg,"l.s $f0,%s\n",val2);
						else
							fprintf(fcg,"mov.s $f0,%s\n",val2);
					}
					else
					{
						if(t2==constant)
							fprintf(fcg,"li $t0,%s\n",val2);
						else if(t2==memory)
							fprintf(fcg,"lw $t0,%s\n",val2);
						else
							fprintf(fcg,"move $t0,%s\n",val2);
						fprintf(fcg,"mtc1 $t0,$f0\n");
						fprintf(fcg,"cvt.s.w $f0,$f0\n");
					}	
					if(!strcmp($2,"="))
					{
						$$=$1;
						if(t1==memory)
							fprintf(fcg,"s.s $f0,%s\n",val1);
						else
							fprintf(fcg,"mov.s %s,$f0\n",val1);
					}
					else if(!strcmp($2,"add") || !strcmp($2,"sub") || !strcmp($2,"mul") || !strcmp($2,"div") || !strcmp($2,"rem"))
					{
						$$=$1;
						if(t1==memory)
						{
							fprintf(fcg,"l.s $f1,%s\n",val1);
							fprintf(fcg,"%s.s $f1,$f1,$f0\n",$2);
							fprintf(fcg,"s.s $f1,%s\n",val1);
						}
						else
						{
							fprintf(fcg,"mov.s $f1,%s\n",val1);
							fprintf(fcg,"%s.s $f1,$f1,$f0\n",$2);
							fprintf(fcg,"mov.s %s,$f1\n",val1);
						}
					}
					else
					{
						$$=$1;
						$$->type=tnone;
						printf("ERROR:incorrect assignment at line %d\n",yylineno);
					}
				}
				else
				{
					if(t2==constant)
						fprintf(fcg,"li $t0,%s\n",val2);
					else if(t2==memory)
						fprintf(fcg,"lw $t0,%s\n",val2);
					else
						fprintf(fcg,"move $t0,%s\n",val2);
					fprintf(fcg,"move %s,$t0\n",val1);
				}
			}
			else if($1->type==tfloat && !($3->type==tdouble || $3->type==tstring || $3->type==tnull || $3->type==tnone || $3->type==tvoid))
			{
				if($3->token==1)
				{
					if($3->type==tdouble || $3->type==tfloat)
					{
						if(t2==constant)
							fprintf(fcg,"li.s $f0,%s\n",val2);
						else if(t2==memory)
							fprintf(fcg,"l.s $f0,%s\n",val2);
						else
							fprintf(fcg,"mov.s $f0,%s\n",val2);
					}
					else
					{
						if(t2==constant)
							fprintf(fcg,"li $t0,%s\n",val2);
						else if(t2==memory)
							fprintf(fcg,"lw $t0,%s\n",val2);
						else
							fprintf(fcg,"move $t0,%s\n",val2);
						fprintf(fcg,"mtc1 $t0,$f0\n");
						fprintf(fcg,"cvt.s.w $f0,$f0\n");
					}	
					if(!strcmp($2,"="))
					{
						$$=$1;
						if(t1==memory)
							fprintf(fcg,"s.s $f0,%s\n",val1);
						else
							fprintf(fcg,"mov.s %s,$f0\n",val1);
					}
					else if(!strcmp($2,"add") || !strcmp($2,"sub") || !strcmp($2,"mul") || !strcmp($2,"div") || !strcmp($2,"rem"))
					{
						$$=$1;
						if(t1==memory)
						{
							fprintf(fcg,"l.s $f1,%s\n",val1);
							fprintf(fcg,"%s.s $f1,$f1,$f0\n",$2);
							fprintf(fcg,"s.s $f1,%s\n",val1);
						}
						else
						{
							fprintf(fcg,"mov.s $f1,%s\n",val1);
							fprintf(fcg,"%s.s $f1,$f1,$f0\n",$2);
							fprintf(fcg,"mov.s %s,$f1\n",val1);
						}
					}
					else
					{
						$$=$1;
						$$->type=tnone;
						printf("ERROR:incorrect assignment at line %d\n",yylineno);
					}
				}
				else
				{
					if(t2==constant)
						fprintf(fcg,"li $t0,%s\n",val2);
					else if(t2==memory)
						fprintf(fcg,"lw $t0,%s\n",val2);
					else
						fprintf(fcg,"move $t0,%s\n",val2);
					fprintf(fcg,"move %s,$t0\n",val1);
				}
			}		
			else if($1->type==tlong && ($3->type==tlong || $3->type==tint || $3->type==tbyte || $3->type==tshort || $3->type==tchar))
                        {
				if(t2==constant)
					fprintf(fcg,"li $t0,%s\n",val2);
				else if(t2==memory)
					fprintf(fcg,"lw $t0,%s\n",val2);
				else
					fprintf(fcg,"move $t0,%s\n",val2);
				if(!strcmp($2,"="))
				{
					if(t1==memory)
						fprintf(fcg,"sw $t0,%s\n",val1);
					else
						fprintf(fcg,"move %s,$t0\n",val1);
				}
				else 
				{
					if(t1==memory)
					{
						fprintf(fcg,"lw $t1,%s\n",val1);
						fprintf(fcg,"%s $t1,$t1,$t0\n",$2);
						fprintf(fcg,"sw $t1,%s\n",val1);
					}
					else
					{
						fprintf(fcg,"move $t1,%s\n",val1);
						fprintf(fcg,"%s $t1,$t1,$t0\n",$2);
						fprintf(fcg,"move %s,$t1\n",val1);
					}
				}
				$$=$1;
			}
			else if($1->type==tint && ($3->type==tint || $3->type==tbyte || $3->type==tshort || $3->type==tchar))
                       	{
				if(t2==constant)
					fprintf(fcg,"li $t0,%s\n",val2);
				else if(t2==memory)
					fprintf(fcg,"lw $t0,%s\n",val2);
				else
					fprintf(fcg,"move $t0,%s\n",val2);
				if(!strcmp($2,"="))
				{
					if(t1==memory)
						fprintf(fcg,"sw $t0,%s\n",val1);
					else
						fprintf(fcg,"move %s,$t0\n",val1);
				}
				else 
				{
					if(t1==memory)
					{
						fprintf(fcg,"lw $t1,%s\n",val1);
						fprintf(fcg,"%s $t1,$t1,$t0\n",$2);
						fprintf(fcg,"sw $t1,%s\n",val1);
					}
					else
					{
						fprintf(fcg,"move $t1,%s\n",val1);
						fprintf(fcg,"%s $t1,$t1,$t0\n",$2);
						fprintf(fcg,"move %s,$t1\n",val1);
					}
				}
				$$=$1;
			}
                	else if($1->type==tshort && ($3->type==tbyte || $3->type==tshort))
                        {
				if(t2==constant)
					fprintf(fcg,"li $t0,%s\n",val2);
				else if(t2==memory)
					fprintf(fcg,"lw $t0,%s\n",val2);
				else
					fprintf(fcg,"move $t0,%s\n",val2);
				if(!strcmp($2,"="))
				{
					if(t1==memory)
						fprintf(fcg,"sw $t0,%s\n",val1);
					else
						fprintf(fcg,"move %s,$t0\n",val1);
				}
				else 
				{
					if(t1==memory)
					{
						fprintf(fcg,"lw $t1,%s\n",val1);
						fprintf(fcg,"%s $t1,$t1,$t0\n",$2);
						fprintf(fcg,"sw $t1,%s\n",val1);
					}
					else
					{
						fprintf(fcg,"move $t1,%s\n",val1);
						fprintf(fcg,"%s $t1,$t1,$t0\n",$2);
						fprintf(fcg,"move %s,$t1\n",val1);
					}
				}
				$$=$1;
			}
                	else if($1->type==tbyte && $3->type==tbyte)
                        {
				if(t2==constant)
					fprintf(fcg,"li $t0,%s\n",val2);
				else if(t2==memory)
					fprintf(fcg,"lw $t0,%s\n",val2);
				else
					fprintf(fcg,"move $t0,%s\n",val2);
				if(!strcmp($2,"="))
				{
					if(t1==memory)
						fprintf(fcg,"sw $t0,%s\n",val1);
					else
						fprintf(fcg,"move %s,$t0\n",val1);
				}
				else 
				{
					if(t1==memory)
					{
						fprintf(fcg,"lw $t1,%s\n",val1);
						fprintf(fcg,"%s $t1,$t1,$t0\n",$2);
						fprintf(fcg,"sw $t1,%s\n",val1);
					}
					else
					{
						fprintf(fcg,"move $t1,%s\n",val1);
						fprintf(fcg,"%s $t1,$t1,$t0\n",$2);
						fprintf(fcg,"move %s,$t1\n",val1);
					}
				}
				$$=$1;
			}
			else if($1->type==tchar && $3->type==tchar)
			{
				if(t2==constant)
					fprintf(fcg,"li $t0,%s\n",val2);
				else if(t2==memory)
					fprintf(fcg,"lw $t0,%s\n",val2);
				else
					fprintf(fcg,"move $t0,%s\n",val2);
				if(!strcmp($2,"="))
				{
					if(t1==memory)
						fprintf(fcg,"sw $t0,%s\n",val1);
					else
						fprintf(fcg,"move %s,$t0\n",val1);
				}
				else 
				{
					if(t1==memory)
					{
						fprintf(fcg,"lw $t1,%s\n",val1);
						fprintf(fcg,"%s $t1,$t1,$t0\n",$2);
						fprintf(fcg,"sw $t1,%s\n",val1);
					}
					else
					{
						fprintf(fcg,"move $t1,%s\n",val1);
						fprintf(fcg,"%s $t1,$t1,$t0\n",$2);
						fprintf(fcg,"move %s,$t1\n",val1);
					}
				}
				$$=$1;
			}
			else if($1->type==tboolean && $3->type==tboolean)
			{
				if(t2==constant)
					fprintf(fcg,"li $t0,%s\n",val2);
				else if(t2==memory)
					fprintf(fcg,"lw $t0,%s\n",val2);
				else
					fprintf(fcg,"move $t0,%s\n",val2);
				if(!strcmp($2,"="))
				{
					$$=$1;
					if(t1==memory)
						fprintf(fcg,"sw $t0,%s\n",val1);
					else
						fprintf(fcg,"move %s,$t0\n",val1);
				}
				else 
				{
					$$=$1;
					$$->type=tnone;
					printf("ERROR:incorrect assignment on line %d\n",yylineno);
				}
			}
                	else
                	{
                        	printf("ERROR:Incorrect usage of = on line %d\n",yylineno);
                        	$$->type=tnone;
                	}
	   	}
	   	else if(($1->token==2 && $3->token==2) || ($1->token==4 && $3->token==4))
	   	{
			if($1->ref!=NULL && $3->ref!=NULL && strcmp($1->ref,$3->ref)==0)
			{
				$$=$1;
				char *val1=Address($1->contains);
				if($1->token==2)
				{
					if(Ref(Address($3->contains))==reg)
						fprintf(fcg,"move $t0,%s\n",Address($3->contains));
					else
						fprintf(fcg,"lw $t0,%s\n",Address($3->contains));
					if(Ref(val1)==memory)
						fprintf(fcg,"sw $t0,%s\n",val1);
					else
						fprintf(fcg,"move %s,$t0\n",val1);
				}
			}
			else if($1->ref!=NULL && $3->ref!=NULL)
			{
				int p1,p2;
				p1=p2=listOfClasses.size()-1;
				while(p1>=0)
				{
					if(!strcmp(listOfClasses[p1].name,$1->ref))
						break;
					else
						p1--;
				}
				while(p2>=0)
				{
					if(!strcmp(listOfClasses[p2].name,$3->ref))
						break;
					else
						p2--;
				}
				if(listOfClasses[p2].extends!=NULL && !strcmp(listOfClasses[p2].extends->name,listOfClasses[p1].name))
				{
					ST *temp=currenter;
					ClassInterface *t=&listOfClasses[currenterpointer];
					while(temp!=NULL)
					{
						if(!findentry(temp,$1->contains))
						{
							temp=temp->prev;
							if(temp==NULL)
							{
								if(t->extends!=NULL)
								{
									temp=t->extends->table;
									t=t->extends;
								}
							}
						}
						else
						{
							STE *entry=findentry(temp,$1->contains);
							strcpy(entry->ref,$3->ref);
							break;
						}
					}
					$$=$3;
					char *val1=Address($1->contains);
					if($1->token==2)
					{
						if(Ref(Address($3->contains))==reg)
							fprintf(fcg,"move $t0,%s\n",Address($3->contains));
						else
							fprintf(fcg,"lw $t0,%s\n",Address($3->contains));
						if(Ref(val1)==memory)
							fprintf(fcg,"sw $t0,%s\n",val1);
						else
							fprintf(fcg,"move %s,$t0\n",val1);
					}
				}
				else
				{
					$$->token=1;
					$$->type=tnone;
				}
			}
			else
                	{
                        	printf("ERROR:Incorrect usage of = on line %d\n",yylineno);
                        	$$->type=tnone;
                	}
	    	}
	   	else
	   	{
                        printf("ERROR:Incorrect usage of = on line %d\n",yylineno);
                        $$->type=tnone;
           	}
	}
	|
	LeftHandSide AssignmentOperator error SEMICOLON	{ $$=(struct attribute *)malloc(sizeof(struct attribute));$$->type=tnone;printf("ERROR:Error in assignment expression on line %d\n",yylineno);}
;
LeftHandSide:
	Identifier
	{
		$$=(struct attribute *)malloc(sizeof(struct attribute));
		ST *temp=currenter;
		bool found=false;
		ClassInterface *t=&listOfClasses[currenterpointer];
		while(temp!=NULL)
		{
			if(!findentry(temp,$1))
			{
				temp=temp->prev;
				if(temp==NULL)
				{
					if(t->extends!=NULL)
					{
						temp=t->extends->table;
						t=t->extends;
					}
				}
			}
			else
			{
				STE *entry=findentry(temp,$1);
				found=true;
				if(temp==t->table)
				{
					if(find(returninfo->modifier.begin(),returninfo->modifier.end(),mstatic)==returninfo->modifier.end())
					{
						//printf("here\n");
						if(find(entry->modifiers.begin(),entry->modifiers.end(),mstatic)==entry->modifiers.end())
						{
							fprintf(fcg,"move $t0,$s7\n");
							int nonstatic=1,i=0,barrier=0,total=1;
							t=&listOfClasses[currenterpointer];
							temp=t->table;
							found=false;
					while(temp!=NULL)
					{
						for(i=0;i<temp->entries.size();i++)
						{
							if(find(temp->entries[i].modifiers.begin(),temp->entries[i].modifiers.end(),mstatic)==temp->entries[i].modifiers.end())
								total++;
						}
						if(t->extends!=NULL)
						{
							temp=t->extends->table;
							t=t->extends;
						}
						else
							temp=NULL;
					}
							t=&listOfClasses[currenterpointer];
							temp=t->table;
					while(temp!=NULL && !found)
					{
						nonstatic=0;
						for(i=0;i<temp->entries.size();i++)
						{
							if(find(temp->entries[i].modifiers.begin(),temp->entries[i].modifiers.end(),mstatic)==temp->entries[i].modifiers.end())
							{
								if(!strcmp(temp->entries[i].lexeme,$1))
								{
									found=true;
									break;
								}
								nonstatic++;
							}
						}
						barrier+=temp->entries.size();
						if(!found)
						{
							if(t->extends!=NULL)
							{
								temp=t->extends->table;
								t=t->extends;
							}
							else
								temp=NULL;
						}
					}
							fprintf(fcg,"addu $t0,$t0,%d\n",4*(nonstatic+total-barrier));
							fprintf(fcg,"move $t%d,$t0\n",next_loc_reg);
							fprintf(fcg,"\n");
							char temp[64];
							temp[0]='0';
							temp[1]='(';
							temp[2]='$';
							temp[3]='t';
							temp[4]='0'+next_loc_reg;
							temp[5]=')';
							temp[6]='\0';
							strcpy($$->contains,temp);
							next_loc_reg=(next_loc_reg+1)%10>=3?(next_loc_reg+1)%10:3;
						}
						else
							strcpy($$->contains,$1);
					}
					else
					{
						if(find(entry->modifiers.begin(),entry->modifiers.end(),mstatic)==entry->modifiers.end())
							printf("ERROR:call to a non static member from inside a static method\n");
						strcpy($$->contains,$1);
					}
				}
				else
					strcpy($$->contains,$1);
				if(entry->btype==tnone)
				{
					$$->token=entry->dimension>0?4:2;
					strcpy($$->ref,entry->ref);
				}
				else
				{
					$$->token=entry->dimension>0?3:1;
					$$->type=entry->btype;	
				}
				$$->dimension=entry->dimension;
				break;
			}
		}
		if(!found)
		{
			$$->type=tnone;
			printf("ERROR:Identifier at line %d not found\n",yylineno);
		}
	}
	|
	FieldAccess		{$$=$1;}
	|
	ArrayAccess		{$$=$1;}
;
UnaryRtoL:
	INCREMENT		{strcpy($$,"add");}
	|	
	DECREMENT		{strcpy($$,"sub");}
;

UnaryLtoR:
	PLUS{strcpy($$,"add");}      %prec UPLUS
	|
	MINUS{strcpy($$,"neg");}    %prec UMINUS
	|
	NOT  {strcpy($$,"bnot");}
	|
	UNOT {strcpy($$,"not");}
;
Cast:
	LRBRACE INT RRBRACE	{$$=new struct attribute;$$->type=tint;strcpy($$->contains,"int");}
	|
	LRBRACE BYTE RRBRACE	{$$=new struct attribute;$$->type=tbyte;strcpy($$->contains,"byte");}
	|
	LRBRACE SHORT RRBRACE	{$$=new struct attribute;$$->type=tshort;strcpy($$->contains,"short");}
	|
	LRBRACE LONG RRBRACE	{$$=new struct attribute;$$->type=tlong;strcpy($$->contains,"long");}
	|
	LRBRACE CHAR RRBRACE	{$$=new struct attribute;$$->type=tchar;strcpy($$->contains,"char");}
	|
	LRBRACE DOUBLE RRBRACE	{$$=new struct attribute;$$->type=tdouble;strcpy($$->contains,"double");}
	|
	LRBRACE FLOAT RRBRACE	{$$=new struct attribute;$$->type=tfloat;strcpy($$->contains,"float");}
	
MultOperator:
	MULT			{strcpy($$,"mul");}
	|
	DIV			{strcpy($$,"div");}
	|
	MOD			{strcpy($$,"rem");}
;
AddOperator:
	PLUS			{strcpy($$,"add");}
	|
	MINUS			{strcpy($$,"sub");}

ShiftOperator:
	LEFTSHIFT		{strcpy($$,"sll");}
	|
	RIGHTSHIFT		{strcpy($$,"sra");}
	|
	URIGHTSHIFT		{strcpy($$,"srl");}
;
RelOperator:
	LT			{strcpy($$,"slt");}
	|
	LEQ			{strcpy($$,"sle");}
	|
	GT			{strcpy($$,"sgt");}
	|
	GEQ			{strcpy($$,"sge");}
	|
	INSTANCEOF		{}
;
CompOperator:
	COMPARE			{strcpy($$,"seq");}
	|
	NEQ			{strcpy($$,"sne");}
;
AssignmentOperator:
	EQUAL			{strcpy($$,"=");}		
	|
	PLUSEQUAL		{strcpy($$,"add");}
	|
	MINUSEQUAL		{strcpy($$,"sub");}
	|
	MULTEQUAL		{strcpy($$,"mul");}
	|
	DIVEQUAL		{strcpy($$,"div");}
	|
	MODEQUAL		{strcpy($$,"rem");}
	|
	ANDEQUAL		{strcpy($$,"and");}
	|
	XOREQUAL		{strcpy($$,"xor");}
	|
	OREQUAL			{strcpy($$,"or");}
	|
	LEFTSHIFTEQUAL		{strcpy($$,"sll");}
	|
	RIGHTSHIFTEQUAL		{strcpy($$,"sra");}
	|
	URIGHTSHIFTEQUAL	{strcpy($$,"srl");}
;	
%%
void createtable(ST *parent)
{
	node = new ST;
	(node->entries).reserve(32*sizeof(STE));
	node->prev=parent;
	currenter=node;
}

void removetable(ST *tab)
{
	ST *temp=currenter;
	temp->entries.clear();
	currenter=tab->prev;
	//free(temp);
}

STE *findentry(ST *tab,char *lexeme)
{
	for(int i=0;i<tab->entries.size();i++)
	{
		if(!strcmp((tab->entries[i]).lexeme,lexeme))
			return &(tab->entries[i]);
	}
	return NULL;
}

void insertentry(ST *tab,char *lexeme,vector<int> m,enum Basic b,char *ref,int dimension,int offset)
{
	STE entry;
	entry.table=tab;
	entry.lexeme=(char *)malloc(256*sizeof(lexeme));
	strcpy(entry.lexeme,lexeme);
	entry.btype=b;
	if(ref!=NULL)
		strcpy(entry.ref,ref);
	entry.dimension=dimension;
	entry.modifiers=m;
	entry.offset=offset;
	tab->entries.push_back(entry);
}

bool compare(vector<struct attribute *>a,vector<struct attribute *>b)
{
	for(int i=0;i<a.size();i++)
	{
		if(a[i]->token!=b[i]->token)
			return false;
		else if(a[i]->dimension!=b[i]->dimension)
			return false;
		else if(a[i]->dimension>0 && b[i]->dimension>0)
		{
			if(a[i]->token==3 && a[i]->type!=b[i]->type)
				return false;
			else if(a[i]->token==4 && strcmp(a[i]->ref,b[i]->ref))
				return false;
		}
		else if(a[i]->token==1)
		{
			if(a[i]->type==tdouble && (b[i]->type==tstring || b[i]->type==tnull || b[i]->type==tnone || b[i]->type==tvoid || b[i]->type==tboolean))
				return false;
			else if(a[i]->type==tfloat && (b[i]->type==tdouble || b[i]->type==tstring || b[i]->type==tnull || b[i]->type==tnone || b[i]->type==tvoid))
				return false;	
			else if(a[i]->type==tlong && !(b[i]->type==tlong || b[i]->type==tint || b[i]->type==tbyte || b[i]->type==tshort || b[i]->type==tchar))
                        	return false;
                	else if(a[i]->type==tint && !(b[i]->type==tint || b[i]->type==tbyte || b[i]->type==tshort || b[i]->type==tchar))
                        	return false;
                	else if(a[i]->type==tshort && !(b[i]->type==tbyte || b[i]->type==tshort))
                        	return false;
                	else if(a[i]->type==tbyte && !(b[i]->type==tbyte))
                        	return false;
			else if(a[i]->type==tchar && b[i]->type!=tchar)
				return false;
			else if(a[i]->type==tboolean && b[i]->type!=tboolean)
				return false;
		}
		else if(a[i]->token==2  && strcmp(a[i]->ref,b[i]->ref))
			return false;
       }
       return true;
}

enum Basic findType(char tmp[],int size)
{
	int i=0;
	long long int val=0;
	while(i<size)
	{
		val=val*10+(tmp[i]-'0');
		i++;
	}
	if(val<128)
		return tbyte;
	else if(val<32767)
		return tshort;
	else if(val<2147483647)
		return tint;
	else
		return tlong;
}

char *getNewTemp()
{
	char * temp = (char *)malloc (5);
	strcpy (temp, "_T00");
	temp [2] = num_temp / 10 + '0';
	temp [3] = num_temp % 10 + '0';
	num_temp++;
	return temp;
}

char *offToAddr(int offset)
{
	if(offset>=100)
	{
		if(offset==100)
			return "20($sp)";
		else if(offset==101)
			return "16($sp)";
		else if(offset==102)
			return "12($sp)";
		else if(offset==103)
			return "8($sp)";
		else if(offset==105)
			return "32($sp)";
		else if(offset==106)
			return "28($sp)";
		else
			return "24($sp)";
	}
	if(offset>=60)
	{
		char *temp=(char *)malloc(5);
		temp[0]='$';
		temp[1]='f';
		temp[2]='0'+(offset-60)/10;
		temp[3]='0'+(offset-60)%10;
		temp[4]='\0';
		return temp;
	}
	if(offset>=50)
	{
		char *temp=(char *)malloc(4);
		temp[0]='$';
		temp[1]='s';
		temp[2]='0'+offset%50;
		temp[3]='\0';
		return temp;
	}
	if(offset>-100)
	{
		char *temp=(char *)malloc(10);
		strcpy(temp,"---($fp)");
		offset=-offset;
		temp[1]=offset/10+'0';
		temp[2]=offset%10+'0';
		return temp;
	}
	else
	{
		char *temp=(char *)malloc(12);
		strcpy(temp,"----($fp)");
		offset=-offset;
		temp[1]=offset/100+'0';
		temp[2]=(offset%100)/10+'0';
		temp[3]=offset%10+'0';
		return temp;
	}
}

char *Address(char *var,int val)
{
	if(var[0]=='$')							//register address
		return var;
	if(var[0]=='-' || (var[0]>='0' && var[0]<='9') || var[0]=='\'')	//constant
		return var;
	else if(var[0]=='_' && var[1]=='T')				//temporary
	{
		int offset=(var[2]-'0')*10+var[3]-'0';
		return offToAddr(offset_temp[offset]);
	}
	else
	{	
		STE *st=NULL;
		ST *temp=currenter;
		while(temp!=NULL && st==NULL)
		{
			st=findentry(temp,var);
			temp=temp->prev;
		}
		if(st!=NULL)
			return offToAddr(st->offset);
		else
			return var;
	}
}
void optimise (char * filename) 
{
	FILE * in = fopen (filename, "r");
	FILE * out = fopen ("codeopt.asm", "w");
	int MAX_LINE_LEN = 50;
	char bufferprev [MAX_LINE_LEN];
	char buffernew [MAX_LINE_LEN];
	int line_number = 0;
	while (fgets (buffernew, MAX_LINE_LEN, in) != 0) 
	{
		if (line_number != 0) 
		{
			if (strcmp (bufferprev+1, buffernew+1)) 
				fprintf (out, "%s", buffernew);
		}
		else 
			fprintf (out, "%s", buffernew);
		line_number ++;
		strcpy (bufferprev, buffernew);
	}
	fclose (in);
	fclose (out);
	char command [50];
	sprintf (command, "mv codeopt.asm %s", filename);
	system (command);
}
	
extern FILE *yyin;
main(int argc,char *argv[])
{
	char * outfilename = (char *)malloc (100);
	strcpy (outfilename, "code.asm");
	fcg = fopen (outfilename, "w");
	do
	{
		yyparse();	
	}
	while(!feof(yyin));
	fclose(fcg);
	if(argc>1)
	{
		printf("code optimised\n");
		optimise(outfilename);
	}
}

